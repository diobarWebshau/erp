import {
    useTableDispatch,
    useTableState
} from "./tableHooks"
import {
    set_row_selection,
    set_sorting,
    clear_row_selection,
    add_column_filter,
    set_column_visibility,
    set_column_filters,
    set_pagination,
} from "./tableActions"
import {
    getCoreRowModel,
    getFilteredRowModel,
    getPaginationRowModel,
    getSortedRowModel,
    useReactTable,

} from "@tanstack/react-table";
import type {
    Column,
    ColumnDef,
    HeaderContext,
    Row,
    Table
} from "@tanstack/react-table";
import type {
    BooleanFilter, ColumnTypeDataFilter,
    EnumFilter, ObjectDateFilter,
    ObjectNumericFilter, RowAction,
    TopButtonAction, WrappedRowAction
} from "../types";
import {
    useEffect,
    useRef, useState,
} from "react";
import {
    useClickOutside
} from "../../../../hooks/useClickOutside";
import RowOptionsToggler
    from "../components/row-options-toggler/RowOptionsToggler copy";
import { Ellipsis }
    from "lucide-react";
import formatDateToDMY
    from "../utils/formatDateToDMY";
import startsWithFilter
    from "../filters/string/startsWithFilter";
import betweenNumberFilter
    from "../filters/number/betweenNumberFilter";
import equalsNumberFilter
    from "../filters/number/equalsNumberFilter";
import betweenDateFilter
    from "../filters/date/betweenDateFilter";
import equalsDateFilter
    from "../filters/date/equalsDateFilter";
import equalsBooleanFilter
    from "../filters/boolean/equalsBooleanFilter";
import GeneratorBodyTable
    from "../components/generator_body-table/GeneratorBodyTable";
import TableFooterControls
    from "../components/table-footer-controls/TableFooterControls";
import GeneratorHeaderTable
    from "../components/generator-header-table/GeneratorHeaderTable";
import stylesModules
    from "./TableBase.module.css"

declare module '@tanstack/react-table' {
    interface ColumnMeta<TData extends unknown, TValue> {
        autoGenerated: boolean,
        type?: 'string' | 'number' | 'date' | 'boolean' | 'enum',
        mode?: 'range' | 'single',
        booleanLabels?: [string, string],
        options?: string[],
        hidden?: boolean,
        isMetaColumn?: boolean,
        typeText?: "password" | "email" | "text",
        numberType?: "integer" | "decimal",
    }
}

interface TableBaseProps<T> {
    modelName: string;
    columns: ColumnDef<T>[];
    data: T[];
    onDeleteSelected: (datas: T[]) => void;
    typeRowActions?: "ellipsis" | "icon";
    rowActions?: RowAction<T>[];
    extraButtons?: TopButtonAction<T>[];
    enableFilters?: boolean;
    enableSorting?: boolean;
    enableViews?: boolean;
    enablePagination?: boolean;
    enableRowSelection?: boolean;
    enableOptionsColumn?: boolean;
    enableRowEditClick?: boolean;
    enableRowEditClickHandler?: (record: T) => void;
    noResultsMessage?: string;
    extraComponents?: (table?: Table<T>) => React.ReactNode;
    footerComponents?: (table: Table<T>) => React.ReactNode;
    classNameGenericTableContainer?: string;
    classNameExtraComponents?: string;
    classNameTableContainer?: string;
    classNameTable?: string;
    classNameTableHeader?: string,
    classNameTableBody?: string,
    classNameFooter?: string;
    classNamePagination?: string;
    expandedComponent?: React.ReactNode;
    isExpanded?: boolean;
    getRowId: (row: T, index: number) => string;
}



const TableBase = <T,>({
    columns,
    data,
    onDeleteSelected,
    rowActions,
    extraButtons,
    typeRowActions = "ellipsis",
    enableFilters = true,
    enableSorting = true,
    enableViews = true,
    enablePagination = true,
    enableRowSelection = true,
    enableOptionsColumn = true,
    noResultsMessage = "No results.",
    enableRowEditClick = false,
    enableRowEditClickHandler,
    extraComponents,
    footerComponents,
    classNameGenericTableContainer,
    classNameExtraComponents,
    classNameTableContainer,
    classNameTable,
    classNameTableHeader,
    classNameTableBody,
    classNameFooter,
    classNamePagination,
    expandedComponent,
    isExpanded,
    getRowId = (_, index) => `temp-${index}`,
}: TableBaseProps<T>) => {

    const dispatch = useTableDispatch();
    const state = useTableState();
    const initializedRef = useRef(false);

    // ? Columna de seleccion
    const selectionColumn: ColumnDef<T> = {
        id: "select",
        header: (ctx: HeaderContext<T, unknown>) => {
            const { table } = ctx;
            return (
                <input
                    className={stylesModules.checkboxHeader}
                    type="checkbox"
                    checked={table.getIsAllPageRowsSelected()}
                    onChange={table.getToggleAllPageRowsSelectedHandler()}
                />
            );
        },
        cell: ({ row }: { row: Row<T> }) => (
            <input
                className={stylesModules.checkbox}
                type="checkbox"
                checked={row.getIsSelected()}
                onChange={row.getToggleSelectedHandler()}
            />
        ),
        enableSorting: false,
        enableHiding: false,
        meta: {
            autoGenerated: false,
            isMetaColumn: true,
        }
    }

    // todo: LOGICA PARA OPCIONES DE COLUMNAS

    const [isActiveRowPopover, setIsActiveRowPopover] =
        useState<string | null>(null);
    const optionsPopoverRef =
        useRef<HTMLDivElement>(null);
    const optionsPopoverTriggerRef =
        useRef<HTMLButtonElement>(null);
    const toggleRowPopover = (rowId: string) => {
        setIsActiveRowPopover(
            (prev) => (prev === rowId ? null : rowId)
        );
    };
    const closePopoverAndClearSelection = () => {
        dispatch(clear_row_selection());
        setIsActiveRowPopover(null);
    };


    const wrapRowActions = <T,>(
        actions: RowAction<T>[],
        rowData: T,
    ): WrappedRowAction[] => {
        return actions.map((action) => ({
            ...action,
            onClick: () => {
                closePopoverAndClearSelection();
                action.onClick(rowData);
            },
            disabled:
                action.disabled
                    ? () => action.disabled!(rowData)
                    : undefined,
        }));
    };

    const deleteRowsSelected = () => {
        const selectedIds = Object.keys(state.rowSelectionState).filter(
            (rowId) => state.rowSelectionState[rowId] === true
        );

        const selectedRows = data.filter((row, index) => {
            const rowId = getRowId(row, index);
            return selectedIds.includes(rowId);
        });

        onDeleteSelected(selectedRows);
        dispatch(clear_row_selection());
    };

    const optionsColumn: ColumnDef<T> = {
        id: "options",
        header: typeRowActions === "icon" ? "Acciones" : () => null, // no renderiza nada, sera una columna  sin placeholder
        cell: ({ row, table }: { row: Row<T>, table: Table<T> }) => (
            <div
                className={stylesModules.optionsColumnContainer}
            >
                {
                    typeRowActions === "ellipsis" ? (
                        <div>
                            <button
                                className={stylesModules.optionsColumnButton}
                                ref={optionsPopoverTriggerRef}
                                onClick={() => { toggleRowPopover(row.id) }}
                            >
                                <Ellipsis size={15} />
                            </button>
                            {
                                rowActions &&
                                    isActiveRowPopover === row.id ? (
                                    <RowOptionsToggler
                                        ref={optionsPopoverRef}
                                        actions={wrapRowActions(rowActions, row.original)}
                                    />
                                ) : null
                            }
                        </div>
                    ) : (

                        <div
                            className={stylesModules.optionsColumn}
                        >
                            {rowActions?.map((action, index) => (
                                <button
                                    className={stylesModules.optionsColumnButton}
                                    type="button"
                                    key={index}
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        action.onClick(row.original);
                                    }}
                                    disabled={action.disabled ? action.disabled(row.original) : false}
                                >
                                    {action.icon}
                                </button>
                            ))}
                        </div>
                    )
                }
            </div >
        ),
        enableSorting: false,
        enableHiding: false,
        meta: {
            autoGenerated: false,
            isMetaColumn: true,
        }
    }
    useClickOutside(
        [optionsPopoverRef, optionsPopoverTriggerRef],
        () => setIsActiveRowPopover(null)
    );


    const handlerAddColumnFilter = (
        column: Column<T>,
        value: ColumnTypeDataFilter,
    ) => {
        let valueInput: ColumnTypeDataFilter;
        switch (column.columnDef.meta?.type) {
            case "string":
                valueInput = value as string[];
                valueInput = valueInput.map((el) => el.trim());
                if (valueInput.length > 0)
                    dispatch(add_column_filter({
                        id: column.id,
                        value: valueInput
                    }));
                break;
            case "number":
                valueInput = value as ObjectNumericFilter;
                console.log("valueInputTable", valueInput);
                if (valueInput?.max !== undefined
                    || valueInput?.min !== undefined)
                    dispatch(add_column_filter({
                        id: column.id,
                        value: {
                            min: valueInput?.min,
                            max: valueInput?.max
                        }
                    }));
                break;
            case "date": {
                // const valueInput = value as ObjectDateFilter;

                // const fromFormatted = valueInput?.from instanceof Date
                //     ? formatDateToDMY(valueInput.from)
                //     : undefined;

                // const toFormatted = valueInput?.to instanceof Date
                //     ? formatDateToDMY(valueInput.to)
                //     : undefined;

                // if (fromFormatted || toFormatted) {
                //     dispatch(add_column_filter({
                //         id: column.id,
                //         value: {
                //             from: fromFormatted,
                //             to: toFormatted
                //         }
                //     }));
                // }

                const valueInput = value as ObjectDateFilter;

                if (valueInput?.from || valueInput?.to) {
                    dispatch(add_column_filter({
                        id: column.id,
                        value: {
                            from: valueInput?.from,
                            to: valueInput?.to
                        }
                    }));
                }

                break;
            }
            case "boolean":
                valueInput = value as BooleanFilter;
                if (valueInput !== undefined)
                    dispatch(add_column_filter({
                        id: column.id,
                        value: valueInput
                    }));
                break;
            case "enum":
                valueInput = value as EnumFilter;
                if (valueInput !== undefined)
                    dispatch(add_column_filter({
                        id: column.id,
                        value: valueInput
                    }));
                break;
        }
    };

    const asignFilterFnToColumns = (columns: ColumnDef<T>[]): ColumnDef<T>[] => {
        const appliedFilterTypeToColumn: ColumnDef<T>[] = columns.map((col) => {
            switch (col.meta?.type) {
                case "string":
                    return {
                        ...col,
                        filterFn: startsWithFilter,
                    };
                case "number":
                    switch (col.meta?.mode) {
                        case "range":
                            return {
                                ...col,
                                filterFn: betweenNumberFilter,
                            };
                        case "single":
                            return {
                                ...col,
                                filterFn: equalsNumberFilter,
                            };
                        default:
                            return col;
                    }
                case "date":
                    switch (col.meta?.mode) {
                        case "range":
                            return {
                                ...col,
                                filterFn: betweenDateFilter,
                            };
                        case "single":
                            return {
                                ...col,
                                filterFn: equalsDateFilter,
                            };
                        default:
                            return col;
                    }
                case "boolean":
                    return {
                        ...col,
                        filterFn: equalsBooleanFilter
                    }
                case "enum":
                    return {
                        ...col,
                        filterFn: startsWithFilter
                    }
                default:
                    return col;
            }
        });
        return appliedFilterTypeToColumn;
    }

    const formattedColumns = <T,>(column: ColumnDef<T>[]): ColumnDef<T>[] => {
        const columnFormatted: ColumnDef<T>[] = column.map((col) => {
            if (col.meta?.type === "date") {
                return {
                    ...col,
                    cell: ({ getValue }) => {
                        return formatDateToDMY(getValue() as string | Date);
                    },
                };
            } else {
                return col;
            }
        })
        return columnFormatted;
    }


    const asignRenderBooleanColumn = <T,>(columns: ColumnDef<T>[]): ColumnDef<T>[] => {
        return columns.map((col) => {
            if (col.meta?.type === "boolean") {
                // Clonamos meta para no mutar original
                const meta = { ...col.meta };

                // Si no tiene booleanLabels, asignamos las por defecto y actualizamos meta
                if (!meta.booleanLabels) {
                    meta.booleanLabels = ["false", "true"];
                }
                return {
                    ...col,
                    meta, // actualizamos meta con booleanLabels garantizados
                    cell: ({ getValue }) => {
                        const boolValue = getValue<boolean>();
                        const display = meta.booleanLabels![Number(boolValue)];
                        return <div>{display}</div>;
                    },
                    filterFn: (row, columnId, filterValue) => {
                        const rawValue = row.getValue(columnId);
                        const rendered = meta.booleanLabels![Number(rawValue)];
                        return rendered === filterValue;
                    },
                };
            }
            return col;
        });
    };

    const processedColumns = (columns: ColumnDef<T>[]): ColumnDef<T>[] => {
        const columnsWithFilters: ColumnDef<T>[] = asignFilterFnToColumns(columns);
        const columnsWithBoolean: ColumnDef<T>[] = asignRenderBooleanColumn(columnsWithFilters);
        const columnsFormatted: ColumnDef<T>[] = formattedColumns(columnsWithBoolean);

        const selectionColumnsEnable: ColumnDef<T>[] = enableRowSelection ? [selectionColumn as ColumnDef<T>] : [];
        const optionsColumnsEnable: ColumnDef<T>[] = enableOptionsColumn ? [optionsColumn as ColumnDef<T>] : [];

        return [...selectionColumnsEnable, ...columnsFormatted, ...optionsColumnsEnable];
    };


    const getStateVisibilityColumns = <T,>(columns: ColumnDef<T>[]) => {
        const visibilityState: Record<string, boolean> = Object.fromEntries(
            columns.map((col) => {
                const key =
                    'id' in col && col.id
                        ? col.id
                        : 'accessorKey' in col && col.accessorKey
                            ? String(col.accessorKey)
                            : ''; // fallback si no tiene ni id ni accessorKey

                return [key, !col.meta?.hidden];
            }).filter(([key]) => key !== '') // eliminamos columnas sin clave
        );
        return visibilityState;
    };


    const table: Table<T> = useReactTable({
        /*  Base data */
        data: data,
        columns: processedColumns(columns),
        getRowId: getRowId,

        getCoreRowModel: getCoreRowModel(),
        ...(enablePagination ? { getPaginationRowModel: getPaginationRowModel() } : {}),
        ...(enableSorting ? { getSortedRowModel: getSortedRowModel() } : {}),
        ...(enableFilters ? { getFilteredRowModel: getFilteredRowModel() } : {}),
        ...(enableRowSelection && {
            onRowSelectionChange: (updater) => {
                dispatch(
                    set_row_selection(
                        typeof updater === 'function'
                            ? updater(state.rowSelectionState)
                            : updater
                    )
                );
            }
        }),
        onColumnVisibilityChange: (updater) => {
            dispatch(
                set_column_visibility(
                    typeof updater === 'function'
                        ? updater(state.columnVisibilityState)
                        : updater
                )
            );
        },

        ...(enableSorting && {
            onSortingChange: (updater) => {
                dispatch(
                    set_sorting(
                        typeof updater === 'function'
                            ? updater(state.sortingState)
                            : updater
                    )
                );
            },
        }),

        ...(enableFilters && {
            onColumnFiltersChange: (updater) => {
                dispatch(
                    set_column_filters(
                        typeof updater === 'function'
                            ? updater(state.columnFiltersState)
                            : updater
                    )
                );
            },
        }),

        ...(enablePagination && {
            onPaginationChange: (updater) => {
                dispatch(
                    set_pagination(
                        typeof updater === 'function'
                            ? updater(state.paginationState)
                            : updater
                    )
                );
            },
        }),
        state: {
            ...(enableRowSelection ? { rowSelection: state.rowSelectionState } : {}),
            columnVisibility: state.columnVisibilityState,
            ...(enableFilters ? { columnFilters: state.columnFiltersState } : {}),
            ...(enablePagination ? { pagination: state.paginationState } : {}),
            ...(enableSorting ? { sorting: state.sortingState } : {}),
        },
    });

    useEffect(() => {
        if (!initializedRef.current) {
            const visibilityState = getStateVisibilityColumns(columns);
            dispatch(set_column_visibility(visibilityState));
            initializedRef.current = true;
        }
    }, []);


    return (
        < div
            className={`${stylesModules.container} ${classNameGenericTableContainer}`}
            style={{
                gap: extraComponents ? "1rem" : "0rem"
            }}
        >
            <section
                className={`${stylesModules.FeaturesContainer} ${classNameExtraComponents}`}
            >
                {extraComponents && (
                    <div
                        className={`${stylesModules.extraComponentsContainer} `}
                    >
                        {extraComponents(table)}
                    </div>
                )}
            </section>
            <section
                className={
                    ` ${stylesModules.containerTableMain} 
                    ${enablePagination || footerComponents
                        ? stylesModules.containerTableMainWithFooterOrPagination
                        : stylesModules.containerTableMainWithoutFooterOrPagination} `
                }
                style={{
                    gap: footerComponents ? "1rem" : "0rem"
                }}
                >
                <section
                    className={
                        `${stylesModules.containerTable} ${classNameTableContainer} `
                        +
                        `${((footerComponents && !enablePagination) || (!enablePagination && !footerComponents)) ? stylesModules.containerTableBorderRadius : ""}`
                    }
                    style={{
                        backgroundColor: "white"
                    }}
                >
                    {table?.getRowModel()?.rows?.length > 0 ? (
                        <section className={stylesModules.tableContainer}>
                            <table
                                className={`${stylesModules.table} ${classNameTable}`}
                            >
                                {
                                    table?.getRowModel()?.rows?.length >= 0 && (
                                        <GeneratorHeaderTable
                                            table={table}
                                            enableSorting={enableSorting}
                                            enableFilters={enableFilters}
                                            handlerOnClickButtonAddFilterColumn={handlerOnClickButtonAddFilterColumn}
                                            className={`${stylesModules.tableHeader} ${classNameTableHeader}`}
                                            typeRowActions={typeRowActions}
                                        />
                                    )}
                                {
                                    table?.getRowModel()?.rows?.length >= 0 && (
                                        <GeneratorBodyTable
                                            table={table}
                                            noResultsMessage={noResultsMessage}
                                            enableRowEditClick={enableRowEditClick}
                                            enableRowEditClickHandler={enableRowEditClickHandler}
                                            className={`${stylesModules.tableBody} ${classNameTableBody}`}
                                            expandedComponent={expandedComponent}
                                            isExpanded={isExpanded}
                                            isHasFooter={footerComponents ? true : false}
                                            isHasPagination={enablePagination}
                                        />
                                    )}
                            </table>
                        </section>

                    ) : (
                        <table
                            className={
                                `${stylesModules.table} ${classNameTable} ` +
                                `${footerComponents ? stylesModules.tableWithoutFooter : ""}`
                            }
                        >
                            {
                                table?.getRowModel()?.rows?.length >= 0 && (
                                    <GeneratorHeaderTable
                                        table={table}
                                        enableSorting={enableSorting}
                                        enableFilters={enableFilters}
                                        handlerOnClickButtonAddFilterColumn={handlerOnClickButtonAddFilterColumn}
                                        className={`${stylesModules.tableHeader} ${classNameTableHeader}`}
                                        typeRowActions={typeRowActions}
                                    />
                                )}
                            {
                                table?.getRowModel()?.rows?.length >= 0 && (
                                    <GeneratorBodyTable
                                        table={table}
                                        noResultsMessage={noResultsMessage}
                                        enableRowEditClick={enableRowEditClick}
                                        enableRowEditClickHandler={enableRowEditClickHandler}
                                        className={`${stylesModules.tableBody} ${classNameTableBody}`}
                                        expandedComponent={expandedComponent}
                                        isExpanded={isExpanded}
                                        isHasFooter={enablePagination ? true : false}
                                        isHasPagination={footerComponents ? true : false}
                                    />
                                )}
                        </table>
                    )}
                </section>
                {(enablePagination || footerComponents) &&
                    <section className={`${stylesModules.containerOption}`}
                    >
                        {
                            footerComponents && (
                                <section
                                    className={`${stylesModules.footerComponentsContainer} ${classNameFooter}`}
                                >
                                    {footerComponents(table)}
                                </section>
                            )
                        }
                        {
                            table?.getRowModel()?.rows?.length >= 0 &&
                            enablePagination && (
                                <TableFooterControls<T>
                                    deleteRowsSelected={deleteRowsSelected}
                                    table={table}
                                    className={`${stylesModules.containerPagination} ${classNamePagination}`}
                                    enableRowSelection={enableRowSelection}
                                />
                            )
                        }
                    </section>
                }
            </section>
        </div >
    )
}


export default TableBase;