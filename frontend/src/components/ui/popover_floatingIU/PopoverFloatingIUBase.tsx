import { useState, type ReactNode } from "react";
import StyleModule from "./PopoverFloatingIUBase.module.css";
import {
    useFloating,          // Hook principal: calcula posici√≥n del elemento flotante (dropdown, tooltip, etc.)
    offset,               // Middleware: agrega espacio entre el bot√≥n (reference) y el men√∫ (floating).
    flip,                 // Middleware: invierte el lado si no cabe (ej. de abajo a arriba).
    shift,                // Middleware: ajusta la posici√≥n para que no se salga de la pantalla.
    size,                 // Middleware: controla ancho/alto del floating (ej. mismo ancho que el bot√≥n).
    autoUpdate,           // Funci√≥n: recalcula posici√≥n autom√°ticamente al cambiar tama√±o/scroll/resize.
    useRole,              // Hook: a√±ade atributos ARIA (ej. role="listbox") para accesibilidad.
    useClick,             // Hook: abre/cierra el floating al hacer click en el reference.
    useDismiss,           // Hook: permite cerrar al hacer click fuera o con la tecla Esc.
    useInteractions,      // Hook: combina varios comportamientos de interacci√≥n (click, dismiss, role, etc.).
    FloatingPortal,       // Componente: renderiza el floating en un portal (fuera del DOM normal).
    FloatingFocusManager, // Componente: gestiona el foco al abrir (muy √∫til en men√∫s y selects).
} from "@floating-ui/react";


type Placement =
    "bottom-start" | "bottom-end" | "bottom" |
    "top-start" | "top-end" | "top" |
    "left-start" | "left-end" | "left" |
    "right-start" | "right-end" | "right";

interface PopoverFloatingIUBaseProps {
    childrenTrigger: ReactNode;
    childrenFloating: ReactNode;
    placement?: Placement;
}

const PopoverFloatingIUBase = ({
    childrenTrigger,
    childrenFloating,
    placement = "bottom-start",
}: PopoverFloatingIUBaseProps) => {


    const [isOpenFloating, setIsOpenFloating] = useState(false);

    // * Configuraci√≥n de Floating UI
    const { refs, floatingStyles, context } = useFloating({
        // ? Estado controlado: el floating se abre/cierra seg√∫n isOpen
        open: isOpenFloating,                       // Booleano: si est√° abierto o cerrado
        onOpenChange: setIsOpenFloating,            // Funci√≥n que actualiza ese estado

        // ? Posici√≥n preferida del floating
        placement: placement,          // Abajo y alineado al inicio (izquierda)

        // ? Hace que la posici√≥n se recalcule autom√°ticamente
        // cuando hay scroll, resize, cambios de layout, etc.
        whileElementsMounted: autoUpdate,

        // ? Lista de middlewares que ajustan la posici√≥n y el tama√±o
        middleware: [
            offset(4),                      // Deja 4px de separaci√≥n entre el bot√≥n y el men√∫
            flip({ padding: 8 }),           // Si no cabe abajo, lo voltea (arriba, derecha, etc.)
            // con un margen de seguridad de 8px
            shift({ padding: 8 }),          // Ajusta el men√∫ para que no se salga de la pantalla,
            // corrigiendo bordes con 8px de padding
            size({
                // ? size ‚Üí controla el ancho/alto del floating
                apply({ rects, elements }) {
                    Object.assign(elements.floating.style, {
                        // Igualar el ancho del floating con el ancho del bot√≥n de referencia
                        width: `${rects.reference.width}px`,
                        // Asegura que nunca sea m√°s angosto que el reference
                        minWidth: `${rects.reference.width}px`,
                        // Forzar que quede siempre encima de otros elementos
                        zIndex: 9999,
                    });
                }
            }),
        ],
    });


    // * Interacciones Floating UI
    const role = useRole(context, { role: "dialog" });
    // ? A√±ade atributos de accesibilidad (ARIA) al floating.
    //    En este caso le dice a lectores de pantalla que el floating
    //    es una "listbox" (como un men√∫ de opciones).

    const click = useClick(context, { event: "mousedown" });
    // ? Controla la apertura/cierre del floating con click (mousedown).
    //    - Si haces click en el "reference" (ej. el bot√≥n), abre o cierra.
    //    - Usa "mousedown" en vez de "click" para que responda m√°s r√°pido.

    const dismiss = useDismiss(context, { outsidePress: true, escapeKey: true });
    // ? Permite cerrar el floating de forma natural:
    //    - outsidePress: true ‚Üí si haces click fuera, se cierra.
    //    - escapeKey: true ‚Üí si presionas Escape, se cierra.

    const { getReferenceProps, getFloatingProps } = useInteractions([
        role,
        click,
        dismiss,
    ]);
    // ? Combina todas las interacciones anteriores en un solo lugar.
    //    - getReferenceProps ‚Üí props que debes pasar al elemento de referencia (bot√≥n o trigger).
    //    - getFloatingProps ‚Üí props que debes pasar al floating (men√∫ o dropdown).
    // As√≠ se aplican autom√°ticamente los eventos, atributos ARIA, etc.
    return (
        <div className={StyleModule.popoverFloatingIUContainer}>
            <div
                className={StyleModule.popoverFloatingTrigger}
                ref={refs.setReference}
                {...getReferenceProps()}
            >
                {childrenTrigger}
            </div>
            {
                isOpenFloating && (
                    <FloatingPortal>
                        <FloatingFocusManager
                            context={context}
                            modal={false}
                            initialFocus={-1}
                        >
                            <div
                                ref={refs.setFloating}
                                {...getFloatingProps()}
                                style={{
                                    ...floatingStyles,
                                }}
                                className={StyleModule.popoverFloatingFloating}
                            >
                                {childrenFloating}
                            </div>
                        </FloatingFocusManager>
                    </FloatingPortal>
                )
            }
        </div>
    );
};


export default PopoverFloatingIUBase;



/*
    üîπ context={context}

        Es el contexto que devuelve useFloating.

        Le permite a FloatingFocusManager saber qu√© es el reference y qu√© es el floating 
        para manejar correctamente el foco.

        Siempre debes pasarlo cuando usas FloatingFocusManager.

    üîπ modal={false}

        Controla si el floating se comporta como un "modal de foco".

        modal={true}

            Hace que el foco quede atrapado dentro del floating (focus trap).

            Marca el resto de la p√°gina con aria-hidden para que los lectores de pantalla
            no puedan acceder al contenido externo mientras est√© abierto.

            √ötil en di√°logos, popovers grandes o men√∫s que bloquean interacci√≥n.

        modal={false}

            No atrapa el foco completamente.

            Permite que todav√≠a puedas tabular fuera del floating.

            √ötil para men√∫s ligeros (selects, tooltips interactivos) donde no quieres 
            ‚Äúbloquear‚Äù todo lo dem√°s.

    üîπ initialFocus={-1}

        Define d√≥nde se coloca el foco autom√°ticamente al abrir el floating.

        Valores posibles:

            0 ‚Üí Foca el primer elemento enfocable dentro del floating.

            un √≠ndice (1, 2, etc.) ‚Üí Foca el N-√©simo elemento enfocable.

            -1 ‚Üí No mueve el foco autom√°ticamente al abrir (mantiene el foco en el 
            reference, o donde estuviera).

            "reference" ‚Üí Devuelve el foco al elemento reference.

            HTMLElement ‚Üí Puedes pasar directamente un nodo al que quieras enfocar.

        En tu caso:

            initialFocus={-1} significa ‚Äúno hagas auto-focus en nada al abrir‚Äù.

            Es √∫til cuando no quieres que el floating robe el foco (por ejemplo, un
            men√∫ que se abre pero prefieres que el foco siga en el bot√≥n).

    ‚úÖ Resumen r√°pido:

    context: conecta con Floating UI.

    modal: controla si el floating atrapa el foco (como modal) o no.

    initialFocus: decide qu√© pasa con el foco al abrir (primer item, reference, nada, etc.).

*/




/*
========================================================
Gu√≠a profunda de @floating-ui/react
========================================================

Este bloque documenta, con detalle y ejemplos, cada pieza que importaste:
- Hooks principales: useFloating, useInteractions
- Middlewares de posicionamiento: offset, flip, shift, size
- Utilidades de rec√°lculo: autoUpdate
- Accesibilidad e interacci√≥n: useRole, useClick, useDismiss
- Infraestructura de render y foco: FloatingPortal, FloatingFocusManager

La idea es que puedas dominar CU√ÅNDO usarlos, C√ìMO configurarlos,
C√ìMO combinarlos y QU√â problemas comunes resuelven.

----------------------------------------------------------------------
1) useFloating (hook base: posicionamiento, refs, estado derivado)
----------------------------------------------------------------------
QU√â ES:
- El cerebro del posicionamiento. Calcula d√≥nde dibujar el "floating"
  (dropdown/tooltip) relativo a un "reference" (bot√≥n, input, etc).

QU√â TE DA:
- x, y: coordenadas calculadas (n√∫meros o null hasta que mide).
- strategy: "absolute" (por defecto) o "fixed" (ignora scroll-ancestors).
- placement: posici√≥n preferida (p.ej. "bottom-start").
- refs: { reference, floating, setReference, setFloating } para enlazar elementos.
- middlewareData: datos extra que exponen los middlewares (ej. flecha, size).
- update(): funci√≥n para forzar recalcular (normalmente no la necesitas si usas autoUpdate).
- context: objeto interno que comparten middlewares y hooks de interacci√≥n.

CU√ÅNDO USARLO:
- Siempre que tengas un elemento dependiente de otro (selects, popovers, men√∫s).

CONFIG CLAVE (ejemplo):
  const {refs, x, y, strategy, context, placement, middlewareData} = useFloating({
    placement: "bottom-start",   // top, right, bottom, left + -start/-end
    strategy: "absolute",         // "fixed" si tu contenedor tiene transforms complejos
    middleware: [offset(8), flip(), shift({padding: 8})],
    whileElementsMounted: autoUpdate, // rec√°lculo reactivo
  });

PATRONES:
- set refs en tus nodes:
    <button ref={refs.setReference} />
    <div ref={refs.setFloating} style={{position: strategy, left: x, top: y}} />

- "fixed" evita bugs si el ancestro tiene transform/overflow: hidden que corta.
- Usa "placement" con sufijos (-start/-end) para alinear bordes.

PROBLEMAS COMUNES:
- Se te mueve al hacer scroll: usa whileElementsMounted: autoUpdate.
- Se corta bajo padres con overflow escondido: usa Portal y/o strategy:"fixed".
- Se descuadra cuando el contenido cambia: size() + autoUpdate.

----------------------------------------------------------------------
2) offset (middleware: separaci√≥n/superposici√≥n entre reference y floating)
----------------------------------------------------------------------
QU√â HACE:
- Controla la distancia entre reference y floating.

FORMAS DE USO:
- offset(n√∫mero): p.ej. offset(8) = 8px de separaci√≥n "externa".
- offset({ mainAxis: 8, crossAxis: 0, alignmentAxis: null })
  - mainAxis: distancia en el eje principal (p.ej. arriba/abajo).
  - crossAxis: desplazamiento lateral (p.ej. a la izquierda/derecha).
  - alignmentAxis: afina la alineaci√≥n cuando usas -start/-end.

CU√ÅNDO USAR:
- Para que el men√∫ no quede pegado al bot√≥n (espaciado visual).
- Para crear "superposici√≥n negativa" (offset(-4)) cuando quieres que se monten.

TIPS:
- Para menus anclados a inputs, un mainAxis 4‚Äì8 generalmente se ve bien.
- crossAxis es √∫til si tu flecha necesita un ajuste fino.

----------------------------------------------------------------------
3) flip (middleware: invierte la posici√≥n si no cabe)
----------------------------------------------------------------------
QU√â HACE:
- Si tu placement preferido no cabe (por viewport o contenedor),
  intenta el opuesto (p.ej. bottom -> top), y tambi√©n variaciones.

OPCIONES:
- fallbackPlacements: ["right", "left"] orden de prueba alternativo.
- padding: margen interno para no pegarse al viewport.

CU√ÅNDO USAR:
- Siempre que el contenido pueda no caber en el primer placement.
- Acordeones, men√∫s contextuales, tooltips responsivos.

PATRONES:
- flip + shift trabajan juntos: flip cambia el lado; shift corrige contra bordes.

----------------------------------------------------------------------
4) shift (middleware: desplaza para evitar recorte contra viewport/contenedor)
----------------------------------------------------------------------
QU√â HACE:
- Si el floating queda parcialmente fuera de los l√≠mites (viewport o boundary),
  lo desplaza para que quede lo m√°s visible posible.

OPCIONES:
- padding: margen de seguridad contra los bordes (ej. 8px).
- limiter: estrategia de recorte (√∫til en tooltips largos).

CU√ÅNDO USAR:
- Siempre que quieras evitar recortes visuales.
- Men√∫s largos, listas con scroll, tooltips en bordes.

PATRONES:
- shift no cambia el lado (eso lo hace flip), solo lo desplaza en el mismo lado.

----------------------------------------------------------------------
5) size (middleware: controla el ancho/alto del floating en funci√≥n del espacio)
----------------------------------------------------------------------
QU√â HACE:
- Permite calcular y fijar dimensiones del floating seg√∫n el espacio disponible,
  o igualar el ancho del reference (men√∫s select tipo "ancho del input").

OPCIONES:
- apply({ rects, availableWidth, availableHeight, elements, ... }):
  callback donde setear styles:
    - elements.floating.style.width = `${rects.reference.width}px`
    - elements.floating.style.maxHeight = `${Math.min(300, availableHeight)}px`
- padding: margen respecto a los l√≠mites al medir availableHeight/Width.

CU√ÅNDO USAR:
- Selects donde el dropdown debe igualar el ancho del bot√≥n/input.
- Men√∫s con altura max limitada y scroll interno.

PATR√ìN CL√ÅSICO:
  size({
    apply({ rects, availableHeight, elements }) {
      elements.floating.style.width = `${rects.reference.width}px`;
      elements.floating.style.maxHeight = `${Math.min(availableHeight, 320)}px`;
    },
  })

----------------------------------------------------------------------
6) autoUpdate (utilidad: rec√°lculo reactivo al montar elementos)
----------------------------------------------------------------------
QU√â HACE:
- Observa cambios de layout: resize, scroll, cambio de fonts, contenido din√°mico,
  y dispara update() autom√°ticamente.

C√ìMO SE USA:
- P√°salo a useFloating como whileElementsMounted: autoUpdate.
  Esto adjunta observers al montar los refs y limpia al desmontar.

CU√ÅNDO USAR:
- Casi siempre. Evita tener que llamar update() manualmente.
- Indispensable si cambian opciones/longitud de la lista al vuelo.

TIPS:
- Si tu dropdown est√° dentro de contenedores con scroll, autoUpdate escucha todo.

----------------------------------------------------------------------
7) useRole (hook: atributos ARIA y sem√°ntica accesible)
----------------------------------------------------------------------
QU√â HACE:
- Devuelve props para asignar role correcto al floating (y a veces al reference).
- Ejemplos:
  - Select/listbox: role="listbox" al contenedor, role="option" a √≠tems.
  - Menu: role="menu" + role="menuitem".
  - Tooltip: role="tooltip".

USO:
  const role = useRole(context, { role: "listbox" });
  const { getFloatingProps } = useInteractions([role]);
  <div {...getFloatingProps()} />

CU√ÅNDO USAR:
- Siempre que el componente tenga sem√°ntica/teclado espec√≠fica.
- Mejora lectores de pantalla y navegaci√≥n por teclado.

----------------------------------------------------------------------
8) useClick (hook: abrir/cerrar con click/toggle)
----------------------------------------------------------------------
QU√â HACE:
- Maneja el estado de visibilidad seg√∫n click del reference.
- Opcionalmente focus/blur, y closeOnPressOutside (aunque esto lo cubre useDismiss).

OPCIONES:
- enabled: boolean (activar/desactivar).
- event: "click" | "mousedown" | "pointerdown" seg√∫n tu UX.
- toggle: si true alterna abierto/cerrado en cada click.

USO:
  const click = useClick(context, { event: "click", toggle: true });

CU√ÅNDO USAR:
- Dropdowns, selects, men√∫s con bot√≥n activador.

PITFALLS:
- En combos avanzados con teclado, combina con useDismiss y FocusManager.

----------------------------------------------------------------------
9) useDismiss (hook: cerrar al hacer click fuera, Esc, blur)
----------------------------------------------------------------------
QU√â HACE:
- Cierra el floating cuando:
  - se hace click/press fuera,
  - se presiona Escape,
  - se pierde el foco (configurable con `outsidePressEvent`, `escapeKey`, etc).

OPCIONES √öTILES:
- outsidePress: true | (event) => boolean (para condicionar qu√© es ‚Äúafuera‚Äù).
- outsidePressEvent: "pointerdown" | "mousedown" | "click".
- escapeKey: boolean (cerrar con Esc).
- bubbles: controla propagaci√≥n seg√∫n tu √°rbol.

USO:
  const dismiss = useDismiss(context, { outsidePress: true, escapeKey: true });

CU√ÅNDO USAR:
- Pr√°cticamente siempre en popovers/menus, para UX consistente.

TIPS:
- Si usas un Portal, outsidePress funciona mejor (no queda ‚Äúdentro‚Äù del mismo stacking).

----------------------------------------------------------------------
10) useInteractions (hook: combina props de interacci√≥n)
----------------------------------------------------------------------
QU√â HACE:
- Junta varios ‚Äúinteractions hooks‚Äù (click, dismiss, role, hover, focus, etc)
  y te devuelve getters de props para reference y floating.

USO:
  const { getReferenceProps, getFloatingProps } = useInteractions([
    useClick(...),
    useDismiss(...),
    useRole(...),
    // otros como useHover, useFocus si los usaras
  ]);

APLICACI√ìN:
  <button ref={refs.setReference} {...getReferenceProps()} />
  <div ref={refs.setFloating} {...getFloatingProps()} />

VENTAJA:
- Centraliza l√≥gica de eventos/ARIA sin repetir onClick/onKeyDown manuales.

----------------------------------------------------------------------
11) FloatingPortal (componente: renderizar fuera del flujo DOM actual)
----------------------------------------------------------------------
QU√â HACE:
- Renderiza el floating en un Portal (al final del body por defecto), evitando:
  - clipping por overflow: hidden de contenedores ancestrales,
  - z-index stacking issues.

USO:
  <FloatingPortal>
    {open && (
      <div ref={refs.setFloating} style={{position: strategy, left: x, top: y}}>
        ...
      </div>
    )}
  </FloatingPortal>

CU√ÅNDO USAR:
- Casi siempre para dropdowns/menus en apps complejas con contenedores scroll.
- Si tu men√∫ ‚Äúdesaparece‚Äù o se recorta, mu√©velo a un Portal.

----------------------------------------------------------------------
12) FloatingFocusManager (componente: gestionar foco y navegaci√≥n)
----------------------------------------------------------------------
QU√â HACE:
- Encierra el floating y gestiona el foco de forma accesible:
  - Tras abrir: mueve foco dentro del panel (opcional).
  - Al cerrar: devuelve el foco al reference (bot√≥n).
  - Atrapa el foco dentro (focus trap) si lo configuras.
  - Administra tab/shift+tab, aria-hidden en siblings, etc.

OPCIONES:
- initialFocus: "reference" | 0 | elemento | null
- returnFocus: boolean (devolver foco al cerrarse)
- modal: boolean (si true, hace aria-hidden a siblings ‚Üí experiencia ‚Äúmodal‚Äù)
- guards: boolean (a√±ade nodos invisibles para trap limpio)

USO:
  <FloatingPortal>
    {open && (
      <FloatingFocusManager context={context} modal={false} initialFocus={0} returnFocus>
        <div ref={refs.setFloating} ...> ... </div>
      </FloatingFocusManager>
    )}
  </FloatingPortal>

CU√ÅNDO USAR:
- Selects, men√∫s y popovers interactivos (inputs dentro, navegaci√≥n por teclado).
- Evita ‚Äúp√©rdida‚Äù de foco y mejora screen readers.

TIPS:
- Si el dropdown es ‚Äúligero‚Äù (solo clicks), modal={false} suele ir bien.
- Para men√∫s complejos tipo combobox, modal={true} asegura enfoque total.

----------------------------------------------------------------------
COMBINACI√ìN T√çPICA PARA UN CUSTOM SELECT
----------------------------------------------------------------------
  const [open, setOpen] = useState(false);

  const {refs, x, y, strategy, context} = useFloating({
    open,
    onOpenChange: setOpen,
    placement: "bottom-start",
    strategy: "fixed",
    whileElementsMounted: autoUpdate,
    middleware: [
      offset(6),
      flip({ padding: 8 }),
      shift({ padding: 8 }),
      size({
        apply({ rects, availableHeight, elements }) {
          elements.floating.style.width = `${rects.reference.width}px`;
          elements.floating.style.maxHeight = `${Math.min(availableHeight, 320)}px`;
          elements.floating.style.overflow = "auto";
        }
      })
    ]
  });

  const click = useClick(context, { toggle: true });
  const dismiss = useDismiss(context, { outsidePress: true, escapeKey: true });
  const role = useRole(context, { role: "listbox" });

  const { getReferenceProps, getFloatingProps } = useInteractions([click, dismiss, role]);

  // JSX (referencia + floating con Portal y FocusManager):
  // <button ref={refs.setReference} {...getReferenceProps()} />
  // <FloatingPortal>
  //   {open && (
  //     <FloatingFocusManager context={context} modal={false} returnFocus>
  //       <div
  //         ref={refs.setFloating}
  //         {...getFloatingProps()}
  //         style={{ position: strategy, left: x ?? 0, top: y ?? 0 }}
  //         role="listbox"
  //       >
  //         {options.map(...)}
  //       </div>
  //     </FloatingFocusManager>
  //   )}
  // </FloatingPortal>

----------------------------------------------------------------------
ANTI-PATRONES Y ERRORES FRECUENTES
----------------------------------------------------------------------
- Olvidar whileElementsMounted: autoUpdate ‚Üí posici√≥n desincronizada al cambiar contenido.
- No usar Portal y chocar con overflow: hidden / z-index ‚Üí men√∫ cortado o invisible.
- No a√±adir role/ARIA ‚Üí navegaci√≥n por teclado pobre, mal soporte lector de pantalla.
- Mezclar handlers manuales (onClick, onKeyDown) con useInteractions mal integrados ‚Üí duplicaci√≥n de eventos.
- No sincronizar "open" con onOpenChange ‚Üí estados ‚Äúdesacoplados‚Äù (el men√∫ no cierra/abre como esperas).
- Fijar height/width en CSS sin respetar size() ‚Üí desalineaci√≥n o scroll no deseado.

----------------------------------------------------------------------
REGLAS DE ORO
----------------------------------------------------------------------
- useFloating + (offset, flip, shift, size) + autoUpdate es el ‚Äústack‚Äù base ganador.
- useInteractions es el pegamento para click/dismiss/role sin boilerplate.
- FloatingPortal casi siempre; FloatingFocusManager cuando el men√∫ es interactivo.
- Pon atenci√≥n a accesibilidad desde el inicio (role correcto + focus controlado).

Con esto tienes una referencia detallada para dominar cada pieza y saber cu√°ndo aplicarla.
*/



/*
============================================================
Gu√≠a general y detallada de @floating-ui/react (no espec√≠fica a un componente)
============================================================

Este documento explica cada API importada ‚Äîpara cualquier patr√≥n UI flotante‚Äî:
tooltips, popovers, men√∫s contextuales, dropdowns, color pickers, autocompletes,
comboboxes, etc. Incluye: qu√© hace, cu√°ndo usarla, configuraci√≥n, patrones,
y errores comunes.

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
HOOKS DE POSICIONAMIENTO
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

1) useFloating
--------------
QU√â ES:
- Hook base que calcula la posici√≥n de un "elemento flotante" (floating)
  relativo a un "elemento de referencia" (reference).

QU√â DEVUELVE (parcial):
- x, y: coordenadas calculadas del floating (pueden ser null hasta que mide).
- placement: posici√≥n preferida ("top" | "right" | "bottom" | "left" + "-start/-end").
- strategy: "absolute" (default) o "fixed" (ignora scroll-ancestors).
- refs: { reference, floating, setReference, setFloating } para conectar nodos DOM/React.
- middlewareData: datos adicionales generados por middlewares (p.ej. size, arrow).
- context: objeto compartido con otros hooks (interactions) y componentes.

CU√ÅNDO USARLO:
- Siempre que un elemento deba posicionarse relativo a otro (tooltip, popover, men√∫‚Ä¶).

CONFIG T√çPICA:
- placement: define lado/alineaci√≥n preferidos.
- strategy: usa "fixed" si hay transforms/overflows que rompen "absolute".
- middleware: array de middlewares (offset, flip, shift, size, arrow‚Ä¶).
- whileElementsMounted: autoUpdate para rec√°lculo reactivo.

PATRONES GENERALES:
- Enlaza refs: setReference al trigger y setFloating al panel flotante.
- Aplica style inline al floating: { position: strategy, left: x, top: y }.

ERRORES COMUNES:
- Sin autoUpdate: posici√≥n desincronizada en scroll/resize/cambios de contenido.
- Sin Portal: clipping por overflow: hidden y stacking context confusos.
- Olvidar "-start/-end": alineaciones inesperadas.

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
MIDDLEWARES DE POSICIONAMIENTO
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

2) offset
---------
QU√â HACE:
- Ajusta la distancia entre el reference y el floating.

USO:
- offset(8) ‚Üí separa 8px.
- offset({ mainAxis, crossAxis, alignmentAxis }) para ajustes finos.

CU√ÅNDO:
- Casi siempre, para evitar que el floating ‚Äúpegue‚Äù al reference.
- Valores 4‚Äì12px suelen verse naturales en tooltips/popovers.

ANTIPATR√ìN:
- offset negativo sin intenci√≥n: puede causar superposici√≥n dif√≠cil de clicar.

3) flip
-------
QU√â HACE:
- Cambia el placement al opuesto/alternativo si no hay espacio en el lado preferido.

OPCIONES:
- fallbackPlacements: orden alternativo (p.ej. ["top", "right"]).
- padding: margen de seguridad con respecto a los l√≠mites.

CU√ÅNDO:
- Casi siempre que el floating pueda no caber (p√°ginas responsivas, layouts complejos).

NOTA:
- flip cambia el LADO; no corrige ‚Äúdesbordes‚Äù finos (eso lo hace shift).

4) shift
--------
QU√â HACE:
- Desplaza el floating dentro de los l√≠mites (viewport/contenedor) para evitar cortes.

OPCIONES:
- padding: espacio m√≠nimo a bordes.
- limiter: estrategias para limitar el corrimiento.

CU√ÅNDO:
- Siempre que quieras mantener el floating visible, incluso en bordes/extremos.

NOTA:
- shift no cambia el lado (flip), solo reposiciona en el mismo lado elegido.

5) size
-------
QU√â HACE:
- Permite establecer dimensiones en funci√≥n del espacio disponible o del reference.

USO HABITUAL:
- Igualar ancho del floating al reference.
- Imponer maxHeight con scroll interno seg√∫n availableHeight.

EJEMPLO MENTAL:
- apply({ rects, availableHeight, elements }) {
    elements.floating.style.width = `${rects.reference.width}px`;
    elements.floating.style.maxHeight = `${Math.min(availableHeight, 320)}px`;
    elements.floating.style.overflow = "auto";
  }

CU√ÅNDO:
- Men√∫s desplegables, listas largas, pickers, autocompletes.

ANTIPATR√ìN:
- Fijar tama√±os r√≠gidos en CSS que ignoren la medici√≥n din√°mica de size().

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ACTUALIZACI√ìN REACTIVA
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

6) autoUpdate
-------------
QU√â HACE:
- Observa scroll, resize, cambios de layout/contenido y recalcula la posici√≥n.

USO:
- P√°salo como whileElementsMounted a useFloating.
- Se encarga de registrar/limpiar observers al montar/desmontar.

CU√ÅNDO:
- Pr√°cticamente siempre, salvo UIs 100% est√°ticas.

ANTIPATR√ìN:
- Llamar update() manual todo el tiempo en lugar de delegar a autoUpdate.

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ACCESIBILIDAD E INTERACCI√ìN
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

7) useRole
----------
QU√â HACE:
- Devuelve props con ARIA roles/atributos apropiados seg√∫n el tipo de floating.

EJEMPLOS:
- role="tooltip" para tooltips.
- role="dialog" para popovers modales.
- role="menu"/"menuitem", "listbox"/"option" para men√∫s y selects.

CU√ÅNDO:
- Siempre: ayuda a lectores de pantalla y navegaci√≥n con teclado.

NOTA:
- Comb√≠nalo con useInteractions para inyectar props sin boilerplate.

8) useClick
-----------
QU√â HACE:
- Gestiona apertura/cierre por interacci√≥n de click (o pointerdown/mousedown).

OPCIONES:
- toggle (true por defecto para dropdown-like).
- event: "click" | "mousedown" | "pointerdown".
- enabled: habilitar/deshabilitar sin desmontar l√≥gica.

CU√ÅNDO:
- Popovers, men√∫s, dropdowns, tooltips con click (en vez de hover).

ANTIPATRONES:
- Con tooltips ‚Äúhover‚Äù, usa useHover (no importado aqu√≠) en lugar de useClick.
- Duplicar handlers manuales onClick + useClick puede crear dobles toggles.

9) useDismiss
-------------
QU√â HACE:
- Cierra el floating al:
  - click/press fuera (outsidePress),
  - pulsar Escape (escapeKey),
  - blur/gestos seg√∫n config.

OPCIONES COMUNES:
- outsidePress: true | (event) => boolean (filtra zonas excepcionales).
- outsidePressEvent: "pointerdown" | "mousedown" | "click".
- escapeKey: boolean.

CU√ÅNDO:
- Casi siempre en popovers/men√∫s para UX consistente y predecible.

TIPS:
- Si renderizas en Portal, outsidePress funciona mejor evitando falsos ‚Äúdentro‚Äù.

10) useInteractions
-------------------
QU√â HACE:
- Combina varios ‚Äúinteraction hooks‚Äù (click, dismiss, role, hover, focus‚Ä¶)
  y devuelve getters de props: getReferenceProps, getFloatingProps.

VENTAJA:
- Centraliza eventos/ARIA, evita repetir onClick/onKeyDown en cada componente.

CU√ÅNDO:
- Siempre que apliques 2+ interacciones/roles al mismo floating/reference.

ANTIPATR√ìN:
- Pasar props manuales y adem√°s los de useInteractions sin cuidado ‚Üí eventos duplicados.

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
RENDERIZADO Y FOCO
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

11) FloatingPortal
------------------
QU√â HACE:
- Renderiza el floating en un portal (p.ej. al final de <body>).

BENEFICIOS:
- Evita clipping por overflow: hidden de contenedores ancestrales.
- Simplifica stacking context/z-index.

CU√ÅNDO:
- Layouts complejos, contenedores con scroll, modales anidados, toolbars fijas.

ANTIPATR√ìN:
- No usar Portal y luego ‚Äúparchear‚Äù con z-index enormes sin resolver clipping.

12) FloatingFocusManager
------------------------
QU√â HACE:
- Gestiona el foco cuando el floating est√° abierto:
  - Puede mover el foco al floating,
  - atrapar el foco (modal) y devolverlo al reference al cerrar,
  - administrar tab/shift+tab, aria-hidden en siblings (si modal).

OPCIONES:
- modal: boolean ‚Äî si true, comportamiento tipo di√°logo modal (oculta resto para SR).
- initialFocus: √≠ndice/elemento/‚Äúreference‚Äù.
- returnFocus: boolean ‚Äî devuelve foco al elemento disparador al cerrar.
- guards: boolean ‚Äî a√±ade nodos sentinela invisibles para trap suave.

CU√ÅNDO:
- Popovers interactivos (formularios, men√∫s navegables, combobox).
- Requisito para accesibilidad s√≥lida con teclado/lectores de pantalla.

ANTIPATR√ìN:
- No manejar foco: usuarios de teclado ‚Äúpierden‚Äù la posici√≥n al abrir/cerrar.

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
PATRONES DE COMBINACI√ìN (GENERALES)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

- Posicionamiento robusto:
  useFloating({
    placement: "bottom-start",
    strategy: "fixed",
    whileElementsMounted: autoUpdate,
    middleware: [offset(8), flip({padding: 8}), shift({padding: 8})]
  })

- Dimensiones reactivas:
  + size(...) para igualar ancho al reference y limitar altura seg√∫n espacio.

- Interacci√≥n accesible:
  const i = useInteractions([useClick(context), useDismiss(context), useRole(context, {role: "dialog" | "menu" | "tooltip" | "listbox"})])

- Infraestructura:
  <FloatingPortal> para escapar de overflow.
  <FloatingFocusManager> para foco y navegaci√≥n.

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
DECISIONES R√ÅPIDAS
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
- ¬øHay posibilidad de que no quepa? ‚Üí flip + shift.
- ¬øSe recorta por contenedores/stacking? ‚Üí FloatingPortal.
- ¬øContenido cambia/tiene scroll/resize? ‚Üí autoUpdate + size.
- ¬øInteracci√≥n con teclado/lectores? ‚Üí useRole + FloatingFocusManager.
- ¬øClick fuera/Escape para cerrar? ‚Üí useDismiss.
- ¬øQuieres evitar bugs con elementos ‚Äúfixed‚Äù/transforms? ‚Üí strategy:"fixed".

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
CHECKLIST DE ERRORES FRECUENTES
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
- No usar whileElementsMounted: autoUpdate ‚Üí desalineaciones en scroll/resize.
- Ignorar Portal ‚Üí el floating ‚Äúdesaparece‚Äù bajo overflow: hidden.
- No establecer role correcto ‚Üí accesibilidad deficiente.
- Duplicar handlers (manual + useInteractions) ‚Üí eventos duplicados.
- Fijar width/height en CSS y olvidar size() ‚Üí desbordes o cortes.
- No manejar foco en UIs complejas ‚Üí mala UX con teclado.

Con esta gu√≠a puedes combinar las piezas para cualquier patr√≥n general:
tooltip (hover + role="tooltip"), popover (click + dismiss + focus manager),
men√∫ contextual (contextmenu + role="menu"), combobox (focus/keyboard + size),
etc. La clave es: useFloating (+middlewares) posiciona; useInteractions gestiona
eventos/ARIA; Portal evita clipping; FocusManager asegura accesibilidad y foco.
*/
