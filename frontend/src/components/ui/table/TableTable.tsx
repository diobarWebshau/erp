// import React, { useState } from "react";
// import { type ColumnDef } from "@tanstack/react-table";
// import GenericTable from "./Table copy 2";
// import { Edit, Trash2, Eye } from "lucide-react";
// import InputNumber from "../general/input-number/InputNamber";

// interface OrderRow {
//     id: number;
//     product_name: string;
//     product_id: number;
// }

// interface RowAction<T> {
//     label: string;
//     icon?: React.ReactNode;
//     onClick: (row: T) => void;
// }

// const PurchasedOrdersTable = () => {
//     const [customValues, setCustomValues] = useState<Record<number, number>>({});

//     const data: OrderRow[] = [
//         { id: 1, product_name: "Manzana", product_id: 101 },
//         { id: 2, product_name: "Banana", product_id: 102 },
//         { id: 3, product_name: "Pera", product_id: 103 },
//     ];

//     const columns: ColumnDef<OrderRow>[] = [
//         {
//             accessorKey: "product_id",
//             header: "ID Producto",
//             meta: { type: "number", autoGenerated: false },
//         },
//         {
//             accessorKey: "product_name",
//             header: "Nombre",
//             meta: { type: "string", autoGenerated: false },
//         },
//         {
//             id: "cantidad",
//             header: "Cantidad",
//             cell: ({ row }) => {
//                 const rowId = row.original.id;
//                 const value = customValues[rowId] ?? 0;

//                 // Acceder a otras columnas
//                 const productName = row.getValue("product_name") as string;
//                 const productId = row.getValue("product_id") as number;

//                 return (
//                     <div style={{ display: "flex", flexDirection: "column", alignItems: "start", gap: "0.25rem" }}>
//                         {/* <input
//                             type="number"
//                             min={0}
//                             value={value}
//                             onChange={(e) => {
//                                 const numeric = Number(e.target.value);
//                                 setCustomValues((prev) => ({
//                                     ...prev,
//                                     [rowId]: numeric,
//                                 }));
//                             }}
//                             style={{ width: "100px" }}
//                         /> */}

//                         <InputNumber
//                             value={value}
//                             onChange={(value) => {
//                                 setCustomValues((prev) => ({
//                                     ...prev,
//                                     [rowId]: value,
//                                 }));
//                             }}
//                         />
//                         <small>Producto: <strong>{productName}</strong></small>
//                         <small>ID: {productId}</small>
//                     </div>
//                 );
//             },
//         }
//     ];

//     const rowActions: RowAction<OrderRow>[] = [
//         {
//             label: "Ver datos",
//             icon: <Eye size={15} />,
//             onClick: (row) => {
//                 const cantidad = customValues[row.id] ?? 0;
//                 console.log("📦 Datos de fila:", row);
//                 console.log("🧮 Cantidad asignada:", cantidad);
//             },
//         },
//         {
//             label: "Editar",
//             icon: <Edit size={15} />,
//             onClick: (row) => {
//                 alert(`Editando producto: ${row.product_name}`);
//             },
//         },
//         {
//             label: "Eliminar",
//             icon: <Trash2 size={15} />,
//             onClick: (row) => {
//                 alert(`Eliminando producto: ${row.product_name}`);
//             },
//         },
//     ];

//     return (
//         <GenericTable<OrderRow>
//             modelName=""
//             data={data}
//             columns={columns}
//             onDeleteSelected={() => { }}
//             rowActions={rowActions}
//         />
//     );
// };

// export default PurchasedOrdersTable;


/* SOLUCION



1. Qué estaba pasando en tu código original
Definiste el array columns directamente dentro del componente, sin usar useMemo.

Cada vez que cambias el estado customValues (al escribir en el input), el componente se vuelve a renderizar y el array columns se vuelve a crear desde cero.

Esto implica que la función cell para la columna "cantidad" es una función nueva en cada renderizado.

React ve que la función para renderizar la celda cambió y desmonta y vuelve a montar el input en cada render.

Al desmontar el input, se pierde el foco en el campo donde estás escribiendo.

Por eso, al escribir un solo dígito, el input pierde foco y la experiencia es mala.

2. Por qué pasa esto
React compara elementos con referencias (== referencia del objeto/función en memoria).

Cuando una función o un objeto se vuelve a crear en cada render, React considera que es diferente y desmonta lo viejo para montar lo nuevo.

El input es un componente controlado: cuando se desmonta y monta, pierde el foco.

El array columns con las funciones inline dentro (cell: ({row}) => {...}) se recrea sin memoización, causando el problema.

3. Cómo se solucionó (en el código recomendado)
Se envolvió la creación del array columns dentro de un useMemo.

Importante: se eliminó la dependencia del estado customValues del useMemo para que el array columns no se vuelva a crear cuando customValues cambia.

La función que actualiza el estado customValues para cada fila se definió con useCallback (también sin dependencias que cambien en cada render).

El componente que renderiza el input se separó en un componente memoizado (React.memo) para evitar renders innecesarios y preservar el foco.

Como resultado:

React ve el array columns como la misma referencia en cada render.

La función cell para la columna "cantidad" es la misma.

React no desmonta el input y el foco se mantiene aunque cambies el valor.

4. Por qué funciona la solución
Usar useMemo para columns evita que React piense que es un array nuevo.

Usar useCallback para la función handleCantidadChange evita que esa función cambie y provoque recreaciones.

Separar la celda en un componente memoizado evita renders innecesarios.

Esto reduce la recreación de componentes y la pérdida de estado/foco dentro del input.

En resumen: React ve los mismos componentes, no los desmonta, y el foco se mantiene.

5. Resumen comparativo
Aspecto	Código Original	Código con solución
Definición de columnas	Array definido inline en render, sin memo	Array definido en useMemo sin dependencias problemáticas
Funciones inline dentro de columnas	Sí (la función cell creada en cada render)	Función cell estable por useMemo
Estado customValues	Cambia, provoca rerender y recrea columnas	Cambia, pero no recrea columnas
Pérdida de foco en input	Sí, porque input se desmonta y monta de nuevo	No, input se mantiene en DOM y mantiene foco
Componentes memoizados	No	Sí, celda input memoizada para evitar rerender

6. En conclusión
El problema principal era que cada cambio en el estado hacía que las funciones y columnas se recrearan, provocando pérdida de foco en inputs controlados.

La solución es usar useMemo para definir columnas y useCallback para las funciones que se pasan a las celdas, y memoizar el componente de celda con input.

Así React detecta que los componentes no han cambiado y mantiene el foco mientras escribes.

*/

import React, { useState, useMemo, useCallback } from "react";
import { type ColumnDef } from "@tanstack/react-table";
import GenericTable from "./Table copy 2";
import { Edit, Trash2, Eye } from "lucide-react";
import InputNumber from "../general/input-number/InputNamber";

interface OrderRow {
  id: number;
  product_name: string;
  product_id: number;
}

interface RowAction<T> {
  label: string;
  icon?: React.ReactNode;
  onClick: (row: T) => void;
}

const CantidadCell = React.memo(
  ({
    rowId,
    value,
    onChange,
    productName,
    productId,
  }: {
    rowId: number;
    value: number;
    onChange: (val: number) => void;
    productName: string;
    productId: number;
  }) => {
    return (
      <div
        style={{
          display: "flex",
          flexDirection: "column",
          gap: "0.25rem",
        }}
      >
        <InputNumber
          id={`cantidad-${rowId}`}
          value={value}
          onChange={onChange}
        />
        <small>
          Producto: <strong>{productName}</strong>
        </small>
        <small>ID: {productId}</small>
      </div>
    );
  }
);

const PurchasedOrdersTable = () => {
  const [customValues, setCustomValues] = useState<Record<number, number>>({});

  const data: OrderRow[] = useMemo(
    () => [
      { id: 1, product_name: "Manzana", product_id: 101 },
      { id: 2, product_name: "Banana", product_id: 102 },
      { id: 3, product_name: "Pera", product_id: 103 },
    ],
    []
  );

  // Crea una función onChange estable que actualice customValues
  // NOTA: aquí no se crea función por fila, sino una genérica que recibe rowId
  const handleCantidadChange = useCallback(
    (rowId: number, value: number) => {
      setCustomValues((prev) => ({
        ...prev,
        [rowId]: value,
      }));
    },
    []
  );

  // Define las columnas UNA SOLA VEZ, sin customValues en las dependencias
  const columns: ColumnDef<OrderRow>[] = useMemo(
    () => [
      {
        accessorKey: "product_id",
        header: "ID Producto",
        meta: { type: "number", autoGenerated: false },
      },
      {
        accessorKey: "product_name",
        header: "Nombre",
        meta: { type: "string", autoGenerated: false },
      },
      {
        id: "cantidad",
        header: "Cantidad",
        cell: ({ row }) => {
          const rowId = row.original.id;
          // Lee el valor del estado actual aquí (no en las dependencias)
          const value = customValues[rowId] ?? 0;
          const productName = row.getValue("product_name") as string;
          const productId = row.getValue("product_id") as number;

          // Esta función es estable porque está memoizada arriba
          const onChange = (val: number) => handleCantidadChange(rowId, val);

          return (
            <CantidadCell
              rowId={rowId}
              value={value}
              onChange={onChange}
              productName={productName}
              productId={productId}
            />
          );
        },
      },
    ],
    [] // **OJO aquí NO va customValues ni handleCantidadChange** para evitar recrear columnas
  );

  const rowActions: RowAction<OrderRow>[] = useMemo(
    () => [
      {
        label: "Ver datos",
        icon: <Eye size={15} />,
        onClick: (row) => {
          const cantidad = customValues[row.id] ?? 0;
          console.log("📦 Datos de fila:", row);
          console.log("🧮 Cantidad asignada:", cantidad);
        },
      },
      {
        label: "Editar",
        icon: <Edit size={15} />,
        onClick: (row) => {
          alert(`Editando producto: ${row.product_name}`);
        },
      },
      {
        label: "Eliminar",
        icon: <Trash2 size={15} />,
        onClick: (row) => {
          alert(`Eliminando producto: ${row.product_name}`);
        },
      },
    ],
    [customValues]
  );

  return (
    <GenericTable<OrderRow>
      modelName=""
      data={data}
      columns={columns}
      onDeleteSelected={() => {}}
      rowActions={rowActions}
      enableSorting={false}
      enableFilters={false}
      enableViews={false}
    />
  );
};

export default PurchasedOrdersTable;
