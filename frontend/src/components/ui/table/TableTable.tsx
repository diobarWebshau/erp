// import React, { useState } from "react";
// import { type ColumnDef } from "@tanstack/react-table";
// import GenericTable from "./Table copy 2";
// import { Edit, Trash2, Eye } from "lucide-react";
// import InputNumber from "../general/input-number/InputNamber";

// interface OrderRow {
//     id: number;
//     product_name: string;
//     product_id: number;
// }

// interface RowAction<T> {
//     label: string;
//     icon?: React.ReactNode;
//     onClick: (row: T) => void;
// }

// const PurchasedOrdersTable = () => {
//     const [customValues, setCustomValues] = useState<Record<number, number>>({});

//     const data: OrderRow[] = [
//         { id: 1, product_name: "Manzana", product_id: 101 },
//         { id: 2, product_name: "Banana", product_id: 102 },
//         { id: 3, product_name: "Pera", product_id: 103 },
//     ];

//     const columns: ColumnDef<OrderRow>[] = [
//         {
//             accessorKey: "product_id",
//             header: "ID Producto",
//             meta: { type: "number", autoGenerated: false },
//         },
//         {
//             accessorKey: "product_name",
//             header: "Nombre",
//             meta: { type: "string", autoGenerated: false },
//         },
//         {
//             id: "cantidad",
//             header: "Cantidad",
//             cell: ({ row }) => {
//                 const rowId = row.original.id;
//                 const value = customValues[rowId] ?? 0;

//                 // Acceder a otras columnas
//                 const productName = row.getValue("product_name") as string;
//                 const productId = row.getValue("product_id") as number;

//                 return (
//                     <div style={{ display: "flex", flexDirection: "column", alignItems: "start", gap: "0.25rem" }}>
//                         {/* <input
//                             type="number"
//                             min={0}
//                             value={value}
//                             onChange={(e) => {
//                                 const numeric = Number(e.target.value);
//                                 setCustomValues((prev) => ({
//                                     ...prev,
//                                     [rowId]: numeric,
//                                 }));
//                             }}
//                             style={{ width: "100px" }}
//                         /> */}

//                         <InputNumber
//                             value={value}
//                             onChange={(value) => {
//                                 setCustomValues((prev) => ({
//                                     ...prev,
//                                     [rowId]: value,
//                                 }));
//                             }}
//                         />
//                         <small>Producto: <strong>{productName}</strong></small>
//                         <small>ID: {productId}</small>
//                     </div>
//                 );
//             },
//         }
//     ];

//     const rowActions: RowAction<OrderRow>[] = [
//         {
//             label: "Ver datos",
//             icon: <Eye size={15} />,
//             onClick: (row) => {
//                 const cantidad = customValues[row.id] ?? 0;
//                 console.log(" Datos de fila:", row);
//                 console.log("М Cantidad asignada:", cantidad);
//             },
//         },
//         {
//             label: "Editar",
//             icon: <Edit size={15} />,
//             onClick: (row) => {
//                 alert(`Editando producto: ${row.product_name}`);
//             },
//         },
//         {
//             label: "Eliminar",
//             icon: <Trash2 size={15} />,
//             onClick: (row) => {
//                 alert(`Eliminando producto: ${row.product_name}`);
//             },
//         },
//     ];

//     return (
//         <GenericTable<OrderRow>
//             modelName=""
//             data={data}
//             columns={columns}
//             onDeleteSelected={() => { }}
//             rowActions={rowActions}
//         />
//     );
// };

// export default PurchasedOrdersTable;


/* SOLUCION



1. Qu茅 estaba pasando en tu c贸digo original
Definiste el array columns directamente dentro del componente, sin usar useMemo.

Cada vez que cambias el estado customValues (al escribir en el input), el componente se vuelve a renderizar y el array columns se vuelve a crear desde cero.

Esto implica que la funci贸n cell para la columna "cantidad" es una funci贸n nueva en cada renderizado.

React ve que la funci贸n para renderizar la celda cambi贸 y desmonta y vuelve a montar el input en cada render.

Al desmontar el input, se pierde el foco en el campo donde est谩s escribiendo.

Por eso, al escribir un solo d铆gito, el input pierde foco y la experiencia es mala.

2. Por qu茅 pasa esto
React compara elementos con referencias (== referencia del objeto/funci贸n en memoria).

Cuando una funci贸n o un objeto se vuelve a crear en cada render, React considera que es diferente y desmonta lo viejo para montar lo nuevo.

El input es un componente controlado: cuando se desmonta y monta, pierde el foco.

El array columns con las funciones inline dentro (cell: ({row}) => {...}) se recrea sin memoizaci贸n, causando el problema.

3. C贸mo se solucion贸 (en el c贸digo recomendado)
Se envolvi贸 la creaci贸n del array columns dentro de un useMemo.

Importante: se elimin贸 la dependencia del estado customValues del useMemo para que el array columns no se vuelva a crear cuando customValues cambia.

La funci贸n que actualiza el estado customValues para cada fila se defini贸 con useCallback (tambi茅n sin dependencias que cambien en cada render).

El componente que renderiza el input se separ贸 en un componente memoizado (React.memo) para evitar renders innecesarios y preservar el foco.

Como resultado:

React ve el array columns como la misma referencia en cada render.

La funci贸n cell para la columna "cantidad" es la misma.

React no desmonta el input y el foco se mantiene aunque cambies el valor.

4. Por qu茅 funciona la soluci贸n
Usar useMemo para columns evita que React piense que es un array nuevo.

Usar useCallback para la funci贸n handleCantidadChange evita que esa funci贸n cambie y provoque recreaciones.

Separar la celda en un componente memoizado evita renders innecesarios.

Esto reduce la recreaci贸n de componentes y la p茅rdida de estado/foco dentro del input.

En resumen: React ve los mismos componentes, no los desmonta, y el foco se mantiene.

5. Resumen comparativo
Aspecto	C贸digo Original	C贸digo con soluci贸n
Definici贸n de columnas	Array definido inline en render, sin memo	Array definido en useMemo sin dependencias problem谩ticas
Funciones inline dentro de columnas	S铆 (la funci贸n cell creada en cada render)	Funci贸n cell estable por useMemo
Estado customValues	Cambia, provoca rerender y recrea columnas	Cambia, pero no recrea columnas
P茅rdida de foco en input	S铆, porque input se desmonta y monta de nuevo	No, input se mantiene en DOM y mantiene foco
Componentes memoizados	No	S铆, celda input memoizada para evitar rerender

6. En conclusi贸n
El problema principal era que cada cambio en el estado hac铆a que las funciones y columnas se recrearan, provocando p茅rdida de foco en inputs controlados.

La soluci贸n es usar useMemo para definir columnas y useCallback para las funciones que se pasan a las celdas, y memoizar el componente de celda con input.

As铆 React detecta que los componentes no han cambiado y mantiene el foco mientras escribes.

*/

import React, { useState, useMemo, useCallback } from "react";
import { type ColumnDef } from "@tanstack/react-table";
import GenericTable from "./Table copy 2";
import { Edit, Trash2, Eye } from "lucide-react";
import InputNumber from "../general/input-number/InputNamber";

interface OrderRow {
  id: number;
  product_name: string;
  product_id: number;
}

interface RowAction<T> {
  label: string;
  icon?: React.ReactNode;
  onClick: (row: T) => void;
}

const CantidadCell = React.memo(
  ({
    rowId,
    value,
    onChange,
    productName,
    productId,
  }: {
    rowId: number;
    value: number;
    onChange: (val: number) => void;
    productName: string;
    productId: number;
  }) => {
    return (
      <div
        style={{
          display: "flex",
          flexDirection: "column",
          gap: "0.25rem",
        }}
      >
        <InputNumber
          id={`cantidad-${rowId}`}
          value={value}
          onChange={onChange}
        />
        <small>
          Producto: <strong>{productName}</strong>
        </small>
        <small>ID: {productId}</small>
      </div>
    );
  }
);

const PurchasedOrdersTable = () => {
  const [customValues, setCustomValues] = useState<Record<number, number>>({});

  const data: OrderRow[] = useMemo(
    () => [
      { id: 1, product_name: "Manzana", product_id: 101 },
      { id: 2, product_name: "Banana", product_id: 102 },
      { id: 3, product_name: "Pera", product_id: 103 },
    ],
    []
  );

  // Crea una funci贸n onChange estable que actualice customValues
  // NOTA: aqu铆 no se crea funci贸n por fila, sino una gen茅rica que recibe rowId
  const handleCantidadChange = useCallback(
    (rowId: number, value: number) => {
      setCustomValues((prev) => ({
        ...prev,
        [rowId]: value,
      }));
    },
    []
  );

  // Define las columnas UNA SOLA VEZ, sin customValues en las dependencias
  const columns: ColumnDef<OrderRow>[] = useMemo(
    () => [
      {
        accessorKey: "product_id",
        header: "ID Producto",
        meta: { type: "number", autoGenerated: false },
      },
      {
        accessorKey: "product_name",
        header: "Nombre",
        meta: { type: "string", autoGenerated: false },
      },
      {
        id: "cantidad",
        header: "Cantidad",
        cell: ({ row }) => {
          const rowId = row.original.id;
          // Lee el valor del estado actual aqu铆 (no en las dependencias)
          const value = customValues[rowId] ?? 0;
          const productName = row.getValue("product_name") as string;
          const productId = row.getValue("product_id") as number;

          // Esta funci贸n es estable porque est谩 memoizada arriba
          const onChange = (val: number) => handleCantidadChange(rowId, val);

          return (
            <CantidadCell
              rowId={rowId}
              value={value}
              onChange={onChange}
              productName={productName}
              productId={productId}
            />
          );
        },
      },
    ],
    [] // **OJO aqu铆 NO va customValues ni handleCantidadChange** para evitar recrear columnas
  );

  const rowActions: RowAction<OrderRow>[] = useMemo(
    () => [
      {
        label: "Ver datos",
        icon: <Eye size={15} />,
        onClick: (row) => {
          const cantidad = customValues[row.id] ?? 0;
          console.log(" Datos de fila:", row);
          console.log("М Cantidad asignada:", cantidad);
        },
      },
      {
        label: "Editar",
        icon: <Edit size={15} />,
        onClick: (row) => {
          alert(`Editando producto: ${row.product_name}`);
        },
      },
      {
        label: "Eliminar",
        icon: <Trash2 size={15} />,
        onClick: (row) => {
          alert(`Eliminando producto: ${row.product_name}`);
        },
      },
    ],
    [customValues]
  );

  return (
    <GenericTable<OrderRow>
      modelName=""
      data={data}
      columns={columns}
      onDeleteSelected={() => {}}
      rowActions={rowActions}
      enableSorting={false}
      enableFilters={false}
      enableViews={false}
    />
  );
};

export default PurchasedOrdersTable;
