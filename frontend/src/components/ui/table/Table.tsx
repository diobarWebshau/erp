import {
    useState, useRef,
    type ChangeEvent, type MouseEvent,
    type RefObject, type JSX
} from "react";
import {
    /* Base */
    // functions
    useReactTable,
    getCoreRowModel,
    flexRender,
    // types
    type ColumnDef,
    type Row,
    type Table,
    type Column,
    type HeaderContext,
    // hide
    type VisibilityState,
    // selection
    type RowSelectionState,
    // sorted
    getSortedRowModel,
    type SortingState,
    type Updater,
    // pagination
    getPaginationRowModel,
    type PaginationState,
    // filter
    getFilteredRowModel,
    // filterFns,
    // type FilterFn,
    type ColumnFiltersState,
    type ColumnFilter,
    type ColumnSort,
} from "@tanstack/react-table";
// iconos
import {
    Ellipsis, Funnel,
    FunnelPlus, ArrowUpDown,
    ArrowUpAZ, ArrowDownZA,
    Delete, CirclePlus
} from "lucide-react"
// para hide
import ColumnVisibilityPopover
    from "./components/table/column-visibility-toggler/ColumnVisibilityToggler";
// para popover
import { useClickOutside }
    from "./customHooks/useClickOutside";
// para options de rows
import RowOptionsToggler
    from "./components/table/row-options-toggler/RowOptionsToggler";
import PaginationControls
    from "./components/table/pagination-controls/PaginationControls";
import StringInput from "./components/gui/filter/string-input/StringInput";
import startsWithFilter
    from "./filters/string/startsWithFilter";
import DraggableList
    from "./components/table/draggable-list/DraggableList";
import NumberSlice
    from "./components/gui/filter/number-slicer/NumberSlicer";
import DateSlicer
    from "./components/gui/filter/date-slicer/DateSlicer";
import type {
    ColumnTypeDataFilter, ObjectDateFilter,
    ObjectNumericFilter, BooleanFilter, EnumFilter
} from "./types";
import betweenNumberFilter
    from "./filters/number/betweenNumberFilter";
import equalsNumberFilter
    from "./filters/number/equalsNumberFilter";
import betweenDateFilter
    from "./filters/date/betweenDateFilter";
import equalsDateFilter
    from "./filters/date/equalsDateFilter";
import formatDateToDMY
    from "./utils/formatDateToDMY";
import equalsBooleanFilter
    from "./filters/boolean/equalsBooleanFilter";
import BooleanInput
    from "./components/gui/filter/boolean-input/BooleanInput";
import EnumSelectInput
    from "./components/gui/filter/enum-input/EnumInput";

declare module '@tanstack/react-table' {
    interface ColumnMeta<TData extends unknown, TValue> {
        autoGenerated: boolean,
        type?: 'string' | 'number' | 'date' | 'boolean' | 'enum' | 'array',
        mode?: 'range' | 'single',
        booleanLabels?: [string, string],
        options?: string[],
        hidden?: boolean,
        isMetaColumn?: boolean,
        typeText?: "password" | "email" | "text",
        numberType?: "integer" | "decimal",
    }
}

// Interfaz genérica para las props de la tabla
interface GenericTableProps<T> {
    modelName: string,
    columns: ColumnDef<T>[];
    data: T[];
    onDelete: (data: T) => void,
    onEdit: (data: T) => void
    onAdd: () => void
    onDeleteSelected: (datas: T[]) => void,
}

const GenericTable = <T,>({
    columns,
    data,
    onDelete,
    onEdit,
    onDeleteSelected,
    onAdd,
}: GenericTableProps<T>) => {

    /** LÓGICA PARA SELECCIÓN DE FILAS
     *
     * @types
     *  - @RowSelectionState
     *      representa el estado de selección de las filas. Es un objeto en el que las claves son 
     *      los IDs de las filas seleccionadas y los valores son booleanos. 
     *      Se usa generalmente con `useState` y se pasa a `useReactTable`.
     *
     *
     * @options
     *  - @enableRowSelection
     *      opción booleana o función que define si se puede seleccionar alguna o todas las filas. 
     *      Se pasa a `useReactTable`. Si es `true`, habilita la selección en todas las filas.
     *
     *  - @onRowSelectionChange
     *      se ejecuta cada vez que el usuario selecciona o deselecciona una fila.
     *      Se utiliza para sincronizar el estado `rowSelection` con `setRowSelection`.
     *
     * @requirements @row
     *  - @getIsSelected
     *      método que devuelve `true` si la fila actual está seleccionada.
     *  - @toggleSelected
     *      método que alterna el estado de selección de la fila actual.
     *  - @getCanSelect
     *      método que indica si una fila puede ser seleccionada (por ejemplo, si se deshabilita).
     *  - @getToggleSelectedHandler
     *      
     * 
     * @requirements @table
     *  - @getSelectedRowModel
     *      método de la tabla para obtener todas las filas seleccionadas. Devuelve un modelo 
     *      de filas que puede ser iterado o transformado según sea necesario.
     *  - @getIsAllPageRowsSelected
     *  - @getToggleAllPageRowsSelectedHandler
     *
     *
     * EJEMPLO DE CICLO:
     * - El usuario hace clic en la checkbox de una fila.
     * - Se dispara `onRowSelectionChange` → actualiza el estado `rowSelection` 
     *   con `setRowSelection`.
     * - La tabla evalúa internamente el nuevo estado y `getSelectedRowModel` 
     *   calcula las filas seleccionadas.
     * - La interfaz se re-renderiza con las filas seleccionadas actualizadas.
     */

    const [rowSelection, setRowSelection] =
        useState<RowSelectionState>({});

    /** declaracion de la columna para seleccion
     * 
     * @params
     *     -- @id
     *          -- Define un identificador único de la columna. Es obligatorio si no 
     *             usas accessorKey ni accessorFn. Útil para columnas virtuales (como
     *             checkboxes, acciones, etc.).
     * 
     *     -- @accessKey
     *          -- Define la clave del objeto data que se va a mostrar en esta columna.
     *             Es la forma más simple y común de mapear datos reales.
     * 
     *     -- @header
     *          -- renderizacion en el encabezado de la columna en la tabla
     *          -- se envia el contexto del header que tiene un objeto que referencia 
     *             al objeto completo de la tabla, porque este checkbox controla la 
     *             seleccion de todas las filas
     *          -- Puede ser una cadena, un componente JSX o una función con acceso al
     *             column y al table.
     *     -- @cell
     *          -- renderizacion en cada celda de la columna en la tabla
     *          -- se envia unicamente la row, porque solo controla la seleccion de esa row
     *          -- Define cómo se muestra el contenido de cada celda de la columna(Puede 
     *             ser una cadena, un componente JSX o una función).
     *          -- puede recibir { row, getValue, column, table }.
     *     -- @footer
     *          -- (igual que header) Define lo que se renderiza como pie de columna.
     *     -- @enableSorting (boolean)
     *          -- Si la columna puede o no ordenarse. Por defecto: true.
     *     -- @enableHiding (boolean)
     *          -- Permite o impide ocultar la columna desde un control de columnas.
     *     -- @enableColumnFilter
     *          -- Controla si esta columna puede tener filtros aplicados.
     *          -- Por defecto: true.
     *     
     */
    const selectionColumn: ColumnDef<T> = {
        id: "select",
        header: (ctx: HeaderContext<T, unknown>) => {
            const { table } = ctx;
            return (
                <input
                    type="checkbox"
                    checked={table.getIsAllPageRowsSelected()}
                    onChange={table.getToggleAllPageRowsSelectedHandler()}
                />
            );
        },
        cell: ({ row }: { row: Row<T> }) => (
            <input
                type="checkbox"
                checked={row.getIsSelected()}
                onChange={row.getToggleSelectedHandler()}
            />
        ),
        enableSorting: false,
        enableHiding: false,
        meta: {
            autoGenerated: false,
            isMetaColumn: true,
        }
    }




    /** LOGICA PARA COLUMNA OPTIONS PARA LAS ROWS
     * 
    */

    const [isActiveRowPopover, setIsActiveRowPopover] = useState<string | null>(null);
    const optionsPopoverRef = useRef<HTMLDivElement>(null);
    const optionsPopoverTriggerRef = useRef<HTMLButtonElement>(null);
    const toggleRowPopover = (rowId: string) => {
        setIsActiveRowPopover((prev) => (prev === rowId ? null : rowId));
    };
    const deleteRow = ({ row, table }: { row: Row<T>, table: Table<T> }) => {
        table.setRowSelection({});
        onDelete(row.original as T);
        setIsActiveRowPopover(null);
    }

    const editRow = ({ row, table }: { row: Row<T>, table: Table<T> }) => {
        table.setRowSelection({});
        onEdit(row.original as T);
        setIsActiveRowPopover(null);
    }

    const deleteRowsSelected = () => {
        const datas: T[] = selectedRows.map(row => row.original);
        onDeleteSelected(datas as T[]);
        setRowSelection({});
    }

    const optionsColumn: ColumnDef<T> = {
        id: "options",
        header: () => null, // no renderiza nada, sera una columna  sin placeholder
        cell: ({ row, table }: { row: Row<T>, table: Table<T> }) => (
            <div
                style={
                    { position: "relative" }
                }
            >
                <button
                    ref={optionsPopoverTriggerRef}
                    style={
                        {
                            width: "100%",
                            height: "100%"
                        }
                    }
                    onClick={() => { toggleRowPopover(row.id) }}
                >
                    <Ellipsis size={15} />
                </button>
                {isActiveRowPopover === row.id && (
                    <RowOptionsToggler
                        ref={optionsPopoverRef}
                        table={table}
                        row={row}
                        onEdit={editRow}
                        onDelete={deleteRow}
                    />)
                }
            </div >
        ),
        enableSorting: false,
        enableHiding: false,
        meta: {
            autoGenerated: false,
            isMetaColumn: true,
        }
    }
    useClickOutside(
        [optionsPopoverRef, optionsPopoverTriggerRef],
        () => setIsActiveRowPopover(null)
    );

    /** LÓGICA PARA PAGINACIÓN
     *
     * @types
     *  - @PaginationState  
     *      representa el estado actual de la paginación. Es un objeto con 
     *      dos propiedades:
     *          `pageIndex` (índice de la página actual, comenzando desde 0) y 
     *          `pageSize` (número de filas por página). Este estado debe ser
     *            controlado con `useState`.
     *
     * @functions
     *  - @getPaginationRowModel  
     *      función que se pasa a `useReactTable` para obtener el modelo de filas 
     *      correspondiente a la página actual, según el `PaginationState`.
     *
     * @options
     *  - @getPaginationRowModel  
     *      opción que se proporciona al crear la tabla con `useReactTable` 
     *      para habilitar el modelo de paginación. Sin esto, la tabla no sabrá 
     *      cómo segmentar las filas.
     *  - @onPaginationChange  
     *      función que se ejecuta cada vez que cambia la página o el tamaño de página. 
     *      Se utiliza para actualizar el estado `pagination` con `setPagination`.
     *
     * @requirements @table
     *  - @getCanNextPage  
     *      retorna `true` si se puede avanzar a la siguiente página.
     *  - @getCanPreviousPage  
     *      retorna `true` si se puede retroceder a la página anterior.
     *  - @nextPage  
     *      método que avanza el estado de paginación a la siguiente página.
     *  - @previousPage  
     *      método que retrocede a la página anterior.
     *  - @setPageIndex  
     *      establece manualmente el índice de la página actual.
     *  - @setPageSize  
     *      establece cuántas filas se deben mostrar por página.
     *  - @getPageCount  
     *      devuelve el número total de páginas calculadas según el total de filas 
     *      y el tamaño de página.
     *
     * EJEMPLO DE CICLO:
     * - El usuario hace clic en el botón "Siguiente".
     * - Se ejecuta `nextPage`, lo que incrementa el `pageIndex`.
     * - Se dispara `onPaginationChange` → actualiza el estado `pagination`.
     * - `getPaginationRowModel` calcula las filas correspondientes a la nueva página.
     * - La tabla se re-renderiza mostrando solo las filas de esa página.
     */

    const [pagination, setPagination] = useState<PaginationState>({
        pageIndex: 0,     // <-- aquí defines la página inicial
        pageSize: 5      // número de elementos por página
    });

    const onChangeSelectRowsPerPage = (e: ChangeEvent<HTMLSelectElement>) => {
        table.setPageSize(Number(e.target.value));
    }


    /** LÓGICA PARA ORDENAR (SORTEAR) COLUMNAS
     *
     * @types
     *  - @SortingState 
     *      representa el estado actual de ordenamiento de la tabla. 
     *      Es un arreglo de objetos que indican qué columna está siendo
     *      ordenada y en qué dirección (ascendente o descendente).
     *  - @ColumnDef 
     *      definición de las columnas, incluyendo la configuración que
     *      permite que una columna sea ordenable, como la propiedad 
     *      `enableSorting`.
     *
     * @functions
     *  - @getSortedRowModel
     *      función que se utiliza para aplicar el ordenamiento a las filas
     *      de la tabla, basada en el estado de `sorting`. Esta función debe
     *      ser incluida en el constructor `useReactTable` para que la tabla
     *      pueda calcular y renderizar las filas ya ordenadas.
     *
     * @options
     *  - @getSortedRowModel
     *      se pasa como una opción en `useReactTable` para que la tabla sepa
     *      cómo obtener y manejar las filas ordenadas. Internamente, reordena
     *      las filas según la configuración actual de `sorting`.
     *  - @onSortingChange
     *      función que se ejecuta cada vez que se cambia el ordenamiento (por
     *      ejemplo, al hacer clic en un encabezado de columna). Generalmente se
     *      usa para actualizar el estado `sorting` con `setSorting`.
     * 
     * @requirements @column  
     *  - @getIsSorted  
     *      método que indica si la columna está ordenada y en qué dirección 
     *      ("asc", "desc" o false).
     *  - @toggleSorting  
     *      método que permite alternar el estado de ordenamiento de una 
     *      columna.
     *  - @setSorting  
     *      función utilizada para modificar el estado global de ordenamiento 
     *      (`sorting`) directamente.
     *
     * EJEMPLO DE CICLO:
     * - El usuario da clic en un encabezado de columna.
     * - Se dispara `onSortingChange` → actualiza el estado `sorting`.
     * - El nuevo estado activa `getSortedRowModel` → reorganiza las filas.
     * - La tabla se re-renderiza con las filas ordenadas.
     */

    // Estado que guarda el sorting aplicado en la tabla
    const [sorting, setSorting] = useState<SortingState>([]);
    // Estado temporal para cambios en el select antes de confirmar
    // const [tempSorting, setTempSorting] = useState<SortingState>([]);
    const [isVisibleSortsListPopover, setIsVisibleSortsListPopover] =
        useState<boolean>(false);
    const filterSortPopoverRef = useRef<HTMLDivElement>(null);
    const triggerRefSortsList = useRef<HTMLButtonElement>(null);

    const handlerOnClickButtonSortsList = (e: MouseEvent<HTMLButtonElement>) => {
        e.preventDefault();
        setIsVisibleSortsListPopover((prev) => !prev);
    }

    useClickOutside(
        [
            filterSortPopoverRef,
            triggerRefSortsList
        ],
        () => setIsVisibleSortsListPopover(false)
    );

    const toggleCycleSortingColumn = (column: Column<T>) => {
        column.toggleSorting(false);
    }




    /**
     * Lógica de ordenamiento cíclico: ascendente → descendente → sin orden
     * @param updater - Puede ser una función que recibe el estado actual o un nuevo estado directo
     * @param sorting - Estado actual de ordenamiento
     * @param setSorting - Setter del estado de ordenamiento (como setState)
     */
    const handleTriStateSortingChange = (updater: Updater<SortingState>) => {
        const next: SortingState =
            typeof updater === "function" ? updater(sorting) : updater;
        const last: ColumnSort | undefined = next.at(-1);
        if (!last) return;

        setSorting((prev) => {
            const exists: ColumnSort | undefined =
                prev.find((s) => s.id === last.id);

            if (exists?.desc === true) {
                return prev.filter((s) => s.id !== last.id);
            }

            if (exists?.desc === false) {
                return prev.map((s) =>
                    s.id === last.id ? { ...s, desc: true } : s
                );
            }

            return [...prev, { id: last.id, desc: false }];
        });
    }

    /** LÓGICA PARA EL FILTRADO
     *
     * @types
     *  - @ColumnFiltersState  
     *      representa el estado del filtrado por columna. Es un arreglo de objetos, 
     *      donde cada objeto contiene `id` (la columna) y `value` (el valor del filtro).  
     *      Este estado se debe controlar con `useState` y pasarse a `useReactTable`.
     *      El orden en el arreglo columnFilters determina el orden en el que se aplican
     *      los filtros.
     *
     * @functions
     *  - @getFilteredRowModel  
     *      función que genera un modelo de filas ya filtradas en base a los filtros activos.  
     *      Es clave para que la tabla muestre los datos según los criterios de filtrado.
     *
     * @options
     *  - @onColumnFiltersChange  
     *      se dispara cada vez que un filtro de columna cambia.  
     *      Sirve para actualizar el estado `columnFilters` con `setColumnFilters`.
     * 
     *  - @getFilteredRowModel  
     *      opción que se pasa al crear la tabla con `useReactTable` para aplicar el filtrado.
     *
     * @requirements @table
     *  - @getCoreRowModel  
     *      necesario para que `getFilteredRowModel` tenga acceso a todas las filas base antes
     *      de aplicar filtros.
     *  - @getFilteredRowModel  
     *      retorna las filas que cumplen con los filtros activos.
     *
     * @requirements @column
     *  - @enableColumnFilter (opcional)  
     *      se puede usar para habilitar o deshabilitar el filtrado por columna individual.
     *  - @filterFn (opcional)  
     *      permite definir una función de filtrado personalizada para esa columna.  
     *      Si no se proporciona, se usará la función por defecto (por ejemplo, incluye texto).
     *
     *
     * EJEMPLO DE USO:
     * - El usuario escribe texto en un input de filtro.
     * - Se ejecuta `onColumnFiltersChange` → actualiza `columnFilters` con `setColumnFilters`.
     * - La tabla evalúa `columnFilters` y aplica `filterFn` por cada columna filtrada.
     * - `getFilteredRowModel` produce un nuevo conjunto de filas filtradas.
     * - La tabla se re-renderiza mostrando solo las filas que cumplen con los filtros.
     */

    const [filterInputValues, setFilterInputValues] =
        useState<Record<string, ColumnTypeDataFilter>>({});
    const [isVisibleFilterPopover, setIsVisibleFilterPopover] = useState<string | null>(null);
    const [isVisibleFiltersListPopover, setIsVisibleFiltersListPopover] =
        useState<boolean>(false);
    const filterListPopoverRef = useRef<HTMLDivElement>(null);
    const triggerRefFilterList = useRef<HTMLButtonElement>(null);
    const [columnFilters, setColumnFilters] =
        useState<ColumnFiltersState>([]);
    const filterPopoverRef = useRef<HTMLDivElement>(null);

    useClickOutside(
        [
            filterListPopoverRef,
            triggerRefFilterList
        ],
        () => setIsVisibleFiltersListPopover(false)
    );
    /*
        Se creó un objeto con referencias para cada botón de filtro de columna (un Record con refs dinámicos).
        Al renderizar cada botón, se guarda su referencia en ese objeto. En useClickOutside se pasan todas esas
        referencias (el popover + todos los botones) como un array para que el hook pueda verificar si el clic 
        fue fuera de todos esos elementos.Si el clic es fuera, se cierra el popover (se llama a 
        setIsVisibleFilterPopover(null)).
    */
    const filterTriggerRefs =
        useRef<Record<string, HTMLButtonElement | null>>({});

    const handlerOnClickButtonFiltersList = (e: MouseEvent<HTMLButtonElement>) => {
        e.preventDefault();
        setIsVisibleFiltersListPopover((prev) => !prev);
    }

    const handlerOnClickButtonFilter = (
        e: MouseEvent<HTMLButtonElement>,
        column: Column<T>,
    ) => {
        e.preventDefault();

        if (isVisibleFilterPopover === column.id) {
            setIsVisibleFilterPopover(null);
        } else {
            let emptyFilterValue: ColumnTypeDataFilter;

            switch (column.columnDef.meta?.type) {
                case "string":
                    emptyFilterValue = "";
                    break;
                case "number":
                    emptyFilterValue = { min: undefined, max: undefined };
                    break;
                case "date":
                    emptyFilterValue = { start: "", end: "" };
                    break;
                case "boolean":
                    emptyFilterValue = undefined;
                    break;
                case "enum":
                    emptyFilterValue = undefined;
                    break;
                default:
                    emptyFilterValue = "";
            }

            setFilterInputValues((prev) => ({
                ...prev,
                [column.id]: emptyFilterValue as ColumnTypeDataFilter,
            }));
            setIsVisibleFilterPopover(column.id);
        }
    };

    useClickOutside(
        [
            filterPopoverRef,
            ...(
                Object.values(filterTriggerRefs.current)
                    .map(
                        (el) => ({ current: el })
                    )
            )
        ],
        () => setIsVisibleFilterPopover(null)
    );

    const handlerOnClickButtonAddFilterColumn = (
        e: React.MouseEvent<HTMLButtonElement>,
        column: Column<T>
    ) => {
        e.preventDefault();
        let valueInput =
            filterInputValues[column.id] as ColumnTypeDataFilter;
        let withoutCurrent: ColumnFilter[] =
            columnFilters.filter((f) => f.id !== column.id);
        switch (column.columnDef.meta?.type) {
            case "string":
                valueInput = valueInput as string;
                if (valueInput.trim() !== "")
                    withoutCurrent =
                        [...withoutCurrent,
                        { id: column.id, value: valueInput }];
                break;
            case "number":
                valueInput = valueInput as ObjectNumericFilter;
                if (valueInput.max !== undefined
                    || valueInput.min !== undefined)
                    withoutCurrent =
                        [
                            ...withoutCurrent,
                            {
                                id: column.id,
                                value: {
                                    min: valueInput.min,
                                    max: valueInput.max
                                }
                            }
                        ];
                break;
            case "date":
                valueInput = valueInput as ObjectDateFilter;
                if (valueInput.start !== "" || valueInput.end !== "")
                    withoutCurrent =
                        [
                            ...withoutCurrent,
                            {
                                id: column.id,
                                value: {
                                    start: formatDateToDMY(valueInput.start),
                                    end: (valueInput.end !== undefined)
                                        ? formatDateToDMY(valueInput.end)
                                        : valueInput.end
                                }
                            }
                        ];
                break;
            case "boolean":
                valueInput = valueInput as BooleanFilter;
                if (valueInput !== undefined)
                    withoutCurrent =
                        [
                            ...withoutCurrent,
                            {
                                id: column.id,
                                value: valueInput
                            }
                        ];
                break;
            case "enum":
                valueInput = valueInput as EnumFilter;
                if (valueInput !== undefined)
                    withoutCurrent =
                        [
                            ...withoutCurrent,
                            {
                                id: column.id,
                                value: valueInput
                            }
                        ];
                break;
        }
        setColumnFilters(withoutCurrent);
        setIsVisibleFilterPopover(null);
    };


    const getValueFieldColumnFilter = (columnId: string): any => {
        const column =
            columnFilters.find((columnFilter) =>
                columnFilter.id == columnId);
        return column?.value ?? "";
    }

    const asignFilterFnToColumns = (columns: ColumnDef<T>[]): ColumnDef<T>[] => {
        const appliedFilterTypeToColumn: ColumnDef<T>[] = columns.map((col) => {
            switch (col.meta?.type) {
                case "string":
                    return {
                        ...col,
                        filterFn: startsWithFilter,
                    };
                case "number":
                    switch (col.meta?.mode) {
                        case "range":
                            return {
                                ...col,
                                filterFn: betweenNumberFilter,
                            };
                        case "single":
                            return {
                                ...col,
                                filterFn: equalsNumberFilter,
                            };
                        default:
                            return col;
                    }
                case "date":
                    switch (col.meta?.mode) {
                        case "range":
                            return {
                                ...col,
                                filterFn: betweenDateFilter,
                            };
                        case "single":
                            return {
                                ...col,
                                filterFn: equalsDateFilter,
                            };
                        default:
                            return col;
                    }
                case "boolean":
                    return {
                        ...col,
                        filterFn: equalsBooleanFilter
                    }
                case "enum":
                    return {
                        ...col,
                        filterFn: startsWithFilter
                    }
                default:
                    return col;
            }
        });
        return appliedFilterTypeToColumn;
    }

    const formattedColumns = (column: ColumnDef<T>[]): ColumnDef<T>[] => {
        const columnFormatted: ColumnDef<T>[] = column.map((col) => {
            if (col.meta?.type === "date") {
                return {
                    ...col,
                    cell: ({ getValue }) => {
                        return formatDateToDMY(getValue<string>());
                    },
                };
            } else {
                return col;
            }
        })
        return columnFormatted;
    }

    // const asignRenderBooleanColumn = (column: ColumnDef<T>[]): ColumnDef<T>[] => {
    //     const columnFormatted: ColumnDef<T>[] = column.map((col) => {
    //         if (col.meta?.type === "boolean") {
    //             const flag: boolean = !col.meta.options;
    //             if (flag) {
    //                 col.meta.options = ["false", "true"];
    //             }
    //             return {
    //                 ...col,
    //                 cell: ({ getValue }) => {
    //                     const options: string[] = col.meta?.options ?? [];
    //                     if (!flag && options.length > 0) {
    //                         return (<div>
    //                             {options[Number(getValue<boolean>())]}
    //                         </div>)

    //                     } else {
    //                         return <div>
    //                             {getValue<boolean>().toString()}
    //                         </div>
    //                     }
    //                 },
    //             };
    //         }

    //         return col;
    //     });

    //     return columnFormatted;
    // };

    const asignRenderBooleanColumn = <T,>(columns: ColumnDef<T>[]): ColumnDef<T>[] => {
        return columns.map((col) => {
            if (col.meta?.type === "boolean") {
                // Clonamos meta para no mutar original
                const meta = { ...col.meta };

                // Si no tiene booleanLabels, asignamos las por defecto y actualizamos meta
                if (!meta.booleanLabels) {
                    meta.booleanLabels = ["false", "true"];
                }
                return {
                    ...col,
                    meta, // actualizamos meta con booleanLabels garantizados
                    cell: ({ getValue }) => {
                        const boolValue = getValue<boolean>();
                        const display = meta.booleanLabels![Number(boolValue)];
                        return <div>{display}</div>;
                    },
                    filterFn: (row, columnId, filterValue) => {
                        const rawValue = row.getValue(columnId);
                        const rendered = meta.booleanLabels![Number(rawValue)];
                        return rendered === filterValue;
                    },
                };
            }
            return col;
        });
    };




    const processedColumns = () => {
        const columnsWithFilters = asignFilterFnToColumns(columns);
        const columnsWithBoolean = asignRenderBooleanColumn(columnsWithFilters);
        const columnsFormatted = formattedColumns(columnsWithBoolean);
        return [selectionColumn, ...columnsFormatted, optionsColumn];
    }

    const getStateVisibilityColumns = <T,>(columns: ColumnDef<T>[]) => {
        const visibilityState: Record<string, boolean> = Object.fromEntries(
            columns.map((col) => {
                const key =
                    'id' in col && col.id
                        ? col.id
                        : 'accessorKey' in col && col.accessorKey
                            ? String(col.accessorKey)
                            : ''; // fallback si no tiene ni id ni accessorKey

                return [key, !col.meta?.hidden];
            }).filter(([key]) => key !== '') // eliminamos columnas sin clave
        );

        return visibilityState;
    };



    // const getCommonValuesFilters = (columnId: string, row: Row<T>) => {
    //     const value = row.getValue(columnId);
    //     const inputValue = filterInputValues[columnId]?.toLowerCase() ?? "";

    //     if (typeof value === "string") {
    //         return value.toLowerCase().startsWith(inputValue);
    //     }

    //     return false;
    // };

    // Actualizar el valor del input en el estado local
    const handlerOnChangeInputTextFilterColumn = (
        value: ColumnTypeDataFilter,
        column: Column<T>
    ) => {
        switch (column.columnDef.meta?.type) {
            case "string":
                const stringValue = value as string;
                setFilterInputValues((prev) => ({
                    ...prev,
                    [column.id]: stringValue as ColumnTypeDataFilter,
                }));
                break;
            case "number":
                switch (column.columnDef.meta?.mode) {
                    case "range": {
                        const numberValue = value as ObjectNumericFilter;
                        const filter: Partial<ObjectNumericFilter> = {
                            min: undefined,
                            max: undefined,
                        };
                        const minValue = Number(numberValue?.min);
                        const maxValue = Number(numberValue?.max);
                        if (minValue !== undefined && !isNaN(minValue))
                            filter.min = minValue;
                        if (maxValue !== undefined && !isNaN(maxValue))
                            filter.max = maxValue;
                        setFilterInputValues((prev) => ({
                            ...prev,
                            [column.id]: filter as ColumnTypeDataFilter,
                        }));
                        break;
                    }
                    case "single": {
                        const numberValue = value as ObjectNumericFilter;
                        const filter: Partial<ObjectNumericFilter> = {
                            min: undefined,
                        };
                        const numValue = Number(numberValue?.min);
                        if (!isNaN(numValue))
                            filter.min = numValue;
                        setFilterInputValues((prev) => ({
                            ...prev,
                            [column.id]: filter as ColumnTypeDataFilter,
                        }));
                        break;
                    }
                }
                break;
            case "date":
                switch (column.columnDef.meta?.mode) {
                    case "range": {
                        const dateValue: ObjectDateFilter =
                            value as ObjectDateFilter;
                        const filter = {
                            start: "",
                            end: ""
                        } as Partial<ObjectDateFilter>;
                        const startValue: string = dateValue?.start ?? "";
                        const endValue: string = dateValue?.end ?? "";
                        filter.start = startValue;
                        filter.end = endValue;
                        setFilterInputValues((prev) => ({
                            ...prev,
                            [column.id]: filter as ColumnTypeDataFilter,
                        }));
                        break;
                    }
                    case "single": {
                        const dateValue: ObjectDateFilter =
                            value as ObjectDateFilter;
                        const filter = {
                            start: "",
                        } as Partial<ObjectDateFilter>;
                        if (dateValue.start !== "")
                            filter.start = dateValue.start;
                        setFilterInputValues((prev) => ({
                            ...prev,
                            [column.id]: filter as ColumnTypeDataFilter,
                        }));
                        break;
                    }
                }
                break;
            case "boolean":
                const booleanValue = value as BooleanFilter;
                setFilterInputValues((prev) => ({
                    ...prev,
                    [column.id]: booleanValue as ColumnTypeDataFilter,
                }));
                break;
            case "enum":
                const enumValue = value as EnumFilter;
                setFilterInputValues((prev) => ({
                    ...prev,
                    [column.id]: enumValue as ColumnTypeDataFilter,
                }));
                break;
        }
    };

    const handleOnClickButtonCommonValuesFilter =
        (e: MouseEvent<HTMLButtonElement>, value: any, column: Column<T>) => {
            e.preventDefault();
            const valor = value as string;
            setFilterInputValues((prev) => ({
                ...prev,
                [column.id]: valor
            }));
        };

    const handleOnClickButtonDeleteFilter =
        (e: MouseEvent<HTMLButtonElement>, columnId: string) => {
            e.preventDefault();
            const withoutCurrent = columnFilters
                .filter((filter) => filter.id !== columnId);
            setColumnFilters(withoutCurrent);
        }

    /** LÓGICA PARA OCULTAR COLUMNAS
     *
     * @types
     *  - @VisibilityState  
     *      representa el estado actual de visibilidad de las columnas.
     *      Es un objeto donde las claves son los IDs de las columnas y
     *      los valores son booleanos que indican si la columna está visible (true) u oculta (false).
     *  - @ColumnDef  
     *      definición de las columnas, incluyendo la configuración que
     *      permite que una columna pueda ser ocultada, como `enableHiding`.
     *
     * @functions
     *  - @setColumnVisibility  
     *      función que permite establecer manualmente el estado de visibilidad
     *      de las columnas. Se puede usar para mostrar u ocultar columnas
     *      de forma programática.
     *
     * @options
     *  - @onColumnVisibilityChange  
     *      función que se ejecuta cuando se produce un cambio en la visibilidad
     *      de cualquier columna. Generalmente se usa para actualizar el estado
     *      `columnVisibility` con `setColumnVisibility`.
     *
     * @requirements @column  
     *  - @getIsVisible  
     *      método que devuelve un booleano indicando si la columna está actualmente visible.
     *  - @toggleVisibility  
     *      método que alterna (muestra u oculta) la visibilidad de una columna específica.
     *  - @setColumnVisibility  
     *      puede ser utilizado para establecer la visibilidad de múltiples columnas.
     *  - @getCanHide  
     *      Retorna un booleano que indica si la columna puede ocultarse, basado en `enableHiding`.
     *  - @getFacetedRowModel  
     *      Permite acceder a las filas visibles desde la perspectiva de esa columna,
     *      útil por ejemplo para obtener valores únicos o contar resultados de búsqueda.
     * 
     * @requirements @column 
     *  - @getAllColumns  
     *      Devuelve todas las columnas, visibles y no visibles. Ideal para listarlas con su visibilidad.
     *
     *  - @getVisibleLeafColumns 
     *      Devuelve solo las columnas visibles (hojas), útil para renderizado.
     *
     *  - @getState --> props -> @columnVisibility  
     *      Retorna el objeto actual de visibilidad (internamente manejado por TanStack).
     *      
     *  - @getFacetedRowModel
     *      Permite acceder a las filas visibles desde la perspectiva de esa columna,
     *      útil por ejemplo para obtener valores únicos o contar resultados de búsqueda.
     *       
     *      
     * EJEMPLO DE CICLO:
     * - El usuario interactúa con un input o checkbox para ocultar una columna.
     * - Se llama `column.toggleVisibility()` o se actualiza `setColumnVisibility`.
     * - Esto actualiza el estado `columnVisibility`.
     * - La tabla se re-renderiza ocultando o mostrando las columnas según el nuevo estado.
     */

    // state que guarda la visibilidad 
    const [columnVisibility, setColumnVisibility] =
        useState<VisibilityState>(getStateVisibilityColumns(columns));
    // state de la visibilidad del popover del boton de columnas
    const [isVisibleHidePopover, setIsVisibleHidePopover] =
        useState<boolean>(false);
    const [valueTextFieldColumnHide, setValueTextFieldColumnHide] =
        useState<string>("");
    const popoverRef: RefObject<HTMLDivElement | null>
        = useRef<HTMLDivElement>(null);
    const triggerRef: RefObject<HTMLButtonElement | null>
        = useRef<HTMLButtonElement>(null);
    const handlerClickButtonVisibblePopoverHideColumn =
        (e: React.MouseEvent<HTMLButtonElement>): void => {
            e.preventDefault();
            setValueTextFieldColumnHide("");
            setIsVisibleHidePopover((prev) => !prev);
        };
    const onChangeTextFieldColumnHide =
        (e: React.ChangeEvent<HTMLInputElement>): void => {
            setValueTextFieldColumnHide(e.target.value);
        };
    const handlerOnClickButtonHideColumn =
        (e: MouseEvent<HTMLButtonElement>, currentColumn: Column<T>): void => {
            e.preventDefault();
            // si es visible
            if (currentColumn.getIsVisible()) {
                // quitamos filtros activos
                if (currentColumn.getIsFiltered()) {
                    const withoutCurrent: ColumnFilter[] =
                        columnFilters.filter((prev) => prev.id !== currentColumn.id)
                    withoutCurrent && setColumnFilters(withoutCurrent);
                }
            }
            // cambiamos la visibilidad
            currentColumn.toggleVisibility();
        }

    useClickOutside(
        [popoverRef, triggerRef],
        () => {
            setIsVisibleHidePopover(false)
        }
    );


    /**
     * CONSTRUCTOR tanStack react table
     * @constructor useReactTable
     */
    const table: Table<T> = useReactTable({
        /*  Base data */
        data: data,
        columns: processedColumns(),
        getCoreRowModel: getCoreRowModel(),
        /* Hidden columns */

        onColumnVisibilityChange: setColumnVisibility,
        /* Sort columns */
        getSortedRowModel: getSortedRowModel(),
        // onSortingChange: setSorting,
        enableMultiSort: true, // <- permite múltiples ordenamientos simultáneos
        onSortingChange: handleTriStateSortingChange,
        /* Selection column or row */
        onRowSelectionChange: setRowSelection,
        /* Pagination  */
        getPaginationRowModel: getPaginationRowModel(),
        onPaginationChange: setPagination,
        /* Filter columns */
        onColumnFiltersChange: setColumnFilters,
        getFilteredRowModel: getFilteredRowModel(),
        /* State table */
        state: {
            pagination,
            columnVisibility,
            rowSelection,
            sorting,
            columnFilters
        },
    });


    /** EXTENSION DE LOGICA PARA SELECCIÓN DE FILAS
     * 
     * 
     */

    const selectedRows = table.getSelectedRowModel().rows;

    return (
        < div
            style={{
                width: '80%',
            }}
        >
            <div
                style={{
                    display: "flex",
                    flexDirection: "row",
                    justifyContent: "end",
                    gap: "0.5rem",
                    width: "100%"
                }}
            >

                {/*  Contenedor para mostar una lista de los filtros aplicados */}
                <div
                    style={{
                        display: "flex",
                        position: "relative"
                    }}
                >
                    <button
                        ref={triggerRefFilterList}
                        disabled={columnFilters.length === 0}
                        onClick={handlerOnClickButtonFiltersList}
                    >
                        Filters
                    </button>
                    {isVisibleFiltersListPopover && (
                        <div
                            ref={filterListPopoverRef}
                            style={{
                                position: "absolute",
                                top: "100%",
                                marginTop: "3%",
                                zIndex: 10,
                                backgroundColor: "black",
                            }}
                        >
                            <DraggableList
                                items={columnFilters}
                                onItemsChange={setColumnFilters}
                                renderItemContent={
                                    (item: ColumnFilter) => {
                                        const column = table.getColumn(item.id);
                                        const meta = column?.columnDef.meta;

                                        const containerStyle: React.CSSProperties = {
                                            display: "flex",
                                            flexDirection: "row",
                                            textAlign: "center",
                                            alignItems: "center",
                                            justifyContent: "space-between",
                                            gap: "0.5rem",
                                        };

                                        const renderValue = (): JSX.Element => {
                                            if (meta?.mode === "range") {
                                                if (meta?.type === "number") {
                                                    const { min, max } = item.value as ObjectNumericFilter;
                                                    return <span>{`${min ?? "—"} - ${max ?? "—"} `}</span>;
                                                }
                                                if (meta?.type === "date") {
                                                    const { start, end } = item.value as ObjectDateFilter;
                                                    return <span>{`${start ?? "—"} - ${end ?? "—"} `}</span>;
                                                }
                                            } else {
                                                if (meta?.type === "number") {
                                                    const { min } = item.value as ObjectNumericFilter;
                                                    return <span>{min}</span>;
                                                } else if (meta?.type === "date") {
                                                    const { start } = item.value as ObjectDateFilter;
                                                    return <span>{start}</span>;
                                                }
                                            }
                                            return <span>{String(item.value)}</span>;
                                        };

                                        return (
                                            <div style={containerStyle}>
                                                <span><strong>{item.id}</strong></span>
                                                {renderValue()}
                                            </div>
                                        );
                                    }
                                }
                            />
                        </div>
                    )}
                </div>
                {/*  Contenedor para mostar una lista de los sorts aplicados */}
                <div
                    style={{
                        display: "flex",
                        position: "relative"
                    }}
                >
                    <button
                        ref={triggerRefSortsList}
                        disabled={sorting.length === 0}
                        onClick={handlerOnClickButtonSortsList}
                    >
                        Sorts
                    </button>
                    {isVisibleSortsListPopover && (
                        <div
                            ref={filterSortPopoverRef}
                            style={{
                                position: "absolute",
                                top: "100%",
                                marginTop: "3%",
                                zIndex: 10,
                                backgroundColor: "black",
                            }}
                        >
                            <DraggableList
                                items={sorting}
                                onItemsChange={setSorting}
                                renderItemContent={(item: ColumnSort) =>
                                    <div
                                        style={{
                                            display: "flex",
                                            flexDirection: "row",
                                            textAlign: "center",
                                            alignItems: "center",
                                            justifyContent: "space-between",
                                            gap: "0.5rem",
                                        }}
                                    >
                                        <span><strong>{item.id as any}</strong></span>
                                        <span>{((item.desc as boolean)) ? "desc" : "asc"}</span>
                                    </div>
                                }
                            />
                        </div>
                    )}
                </div>
                {/*  Contenedor para esconder columnas */}
                <div className="hide_container"
                    style={
                        {
                            position: "relative"
                        }
                    }
                >
                    <button
                        onClick={handlerClickButtonVisibblePopoverHideColumn}
                        ref={triggerRef}
                    >
                        Views
                    </button>
                    {isVisibleHidePopover && (
                        <ColumnVisibilityPopover<T>
                            popoverRef={popoverRef}
                            valueTextFieldColumnHide={valueTextFieldColumnHide}
                            onChangeTextFieldColumnHide={onChangeTextFieldColumnHide}
                            onClickButtonHideColumn={handlerOnClickButtonHideColumn}
                            columns={table.getAllColumns()}
                        />
                    )}
                </div>
                <div>
                    <button
                        onClick={onAdd}
                        style={{
                            display: "flex",
                            flexDirection: "row",
                            justifyContent: "center",
                            alignItems: "center",
                            gap: "0.5rem"
                        }}
                    >
                        <small>Add</small>
                        <CirclePlus size={15} />
                    </button>
                </div>
            </div>
            <div
                style={{
                    width: '100%',
                }}
            >
                <table
                    border={1} cellPadding={5} cellSpacing={0}
                    style={{
                        width: "100%",
                        textAlign: "center"
                    }}
                >
                    <thead>
                        {table.getHeaderGroups().map((group) => (
                            <tr key={group.id}>
                                {group.headers.map((header) => (
                                    <th key={header.id}
                                    >
                                        <div
                                            style={{
                                                display: "flex",
                                                flexDirection: "row",
                                                justifyContent: "center"
                                            }}
                                        >
                                            {
                                                header.id === "select" ? (
                                                    flexRender(
                                                        header.column.columnDef.header,
                                                        header.getContext()
                                                    )
                                                ) : header.id === "options" ? (
                                                    null
                                                ) : (
                                                    <div
                                                        style={{
                                                            display: "flex",
                                                            flexDirection: "row",
                                                            flexWrap: "nowrap",
                                                            alignItems: "center",
                                                            gap: "0.5rem",
                                                        }}
                                                    >
                                                        <div>
                                                            <button
                                                                disabled={!(header.column.getFacetedRowModel().rows.length > 0)}
                                                                onClick={() => toggleCycleSortingColumn(header.column)}
                                                                style={{
                                                                    display: "flex",
                                                                    flexDirection: "row",
                                                                    justifyContent: "space-between",
                                                                    alignItems: "center",
                                                                    minWidth: "100px",
                                                                    width: "100%",
                                                                }}
                                                            >
                                                                <small>
                                                                    {header.isPlaceholder
                                                                        ? null
                                                                        : flexRender(
                                                                            header.column.columnDef.header,
                                                                            header.getContext()
                                                                        )}
                                                                </small>
                                                                {!header.column.getIsSorted() ? (
                                                                    <ArrowUpDown size={15} />
                                                                ) : header.column.getIsSorted() === "asc" ? (
                                                                    <ArrowUpAZ size={15} color="yellow" />
                                                                ) : (
                                                                    <ArrowDownZA size={15} color="yellow" />
                                                                )}
                                                            </button>
                                                        </div>
                                                        <div
                                                            style={{
                                                                position: "relative"
                                                            }}
                                                        >
                                                            <button
                                                                disabled={!(header.column.getFacetedRowModel().rows.length > 0)}
                                                                ref={(el) => {
                                                                    if (el) {
                                                                        filterTriggerRefs.current[header.column.id] = el;
                                                                    }
                                                                }} onClick={(e) => handlerOnClickButtonFilter(e, header.column)}
                                                            >
                                                                {header.column.getIsFiltered() ? (
                                                                    <FunnelPlus size={15} color="red" />
                                                                ) : (
                                                                    <Funnel size={15} />
                                                                )}
                                                            </button>
                                                            {
                                                                isVisibleFilterPopover === header.column.id && (
                                                                    <div
                                                                        ref={filterPopoverRef}
                                                                        style={
                                                                            {
                                                                                position: "absolute",
                                                                                top: "100%",
                                                                                marginTop: "3%",
                                                                                zIndex: 10,
                                                                                backgroundColor: "black"
                                                                            }
                                                                        }
                                                                    >
                                                                        {header.column.getIsFiltered() &&
                                                                            <div
                                                                                style={{
                                                                                    display: "flex",
                                                                                    flexDirection: "column"

                                                                                }}
                                                                            >
                                                                                <small>
                                                                                    Active filter:
                                                                                </small>
                                                                                <div>
                                                                                    <div>
                                                                                        {
                                                                                            header.column.columnDef.meta?.type === "string" && (
                                                                                                <small>
                                                                                                    {getValueFieldColumnFilter(header.column.id)}
                                                                                                </small>
                                                                                            )
                                                                                        }
                                                                                        {
                                                                                            (header.column.columnDef.meta?.type === "number" &&
                                                                                                header.column.columnDef.meta?.mode === "range")
                                                                                                ? (

                                                                                                    <small>
                                                                                                        {`${getValueFieldColumnFilter(header.column.id)?.min} `
                                                                                                            + `- ${getValueFieldColumnFilter(header.column.id)?.max} `}
                                                                                                    </small>
                                                                                                )
                                                                                                : (
                                                                                                    <small>
                                                                                                        {getValueFieldColumnFilter(header.column.id)?.min}
                                                                                                    </small>
                                                                                                )
                                                                                        }
                                                                                        {
                                                                                            header.column.columnDef.meta?.type === "date" &&
                                                                                                header.column.columnDef.meta?.mode === "range"
                                                                                                ? (
                                                                                                    <small>
                                                                                                        {`${getValueFieldColumnFilter(header.column.id)?.start} `
                                                                                                            + `- ${getValueFieldColumnFilter(header.column.id)?.end} `}
                                                                                                    </small>
                                                                                                )
                                                                                                : (
                                                                                                    <small>
                                                                                                        {getValueFieldColumnFilter(header.column.id)?.start}
                                                                                                    </small>
                                                                                                )
                                                                                        }
                                                                                        {
                                                                                            header.column.columnDef.meta?.type === "boolean" && (
                                                                                                <small>
                                                                                                    {String(getValueFieldColumnFilter(header.column.id))}
                                                                                                </small>
                                                                                            )
                                                                                        }
                                                                                        {
                                                                                            header.column.columnDef.meta?.type === "enum" && (
                                                                                                <small>
                                                                                                    {String(getValueFieldColumnFilter(header.column.id))}
                                                                                                </small>
                                                                                            )
                                                                                        }
                                                                                    </div>

                                                                                    <button
                                                                                        onClick={(e) => handleOnClickButtonDeleteFilter(e, header.column.id)}
                                                                                    >
                                                                                        <Delete size={15} color="red" />
                                                                                    </button>
                                                                                </div>
                                                                            </div>
                                                                        }
                                                                        {
                                                                            header.column.columnDef.meta?.type === "string" && (
                                                                                <div>
                                                                                    <StringInput
                                                                                        label={header.id}
                                                                                        type="text"
                                                                                        value={(String(filterInputValues[header.column.id]))
                                                                                            ?? getValueFieldColumnFilter(header.column.id)}
                                                                                        defaultValue={getValueFieldColumnFilter(header.column.id)}
                                                                                        onChange={(value) => {
                                                                                            handlerOnChangeInputTextFilterColumn(value, header.column)
                                                                                        }}
                                                                                    />
                                                                                    <div>
                                                                                        <small>
                                                                                            Common values
                                                                                        </small>
                                                                                        <div
                                                                                            style={
                                                                                                {
                                                                                                    display: "flex",
                                                                                                    flexDirection: "column",
                                                                                                    height: "100px",
                                                                                                    overflowY: "auto"
                                                                                                }
                                                                                            }
                                                                                        >
                                                                                            {table
                                                                                                .getFilteredRowModel()
                                                                                                .rows
                                                                                                .map(row => row.getValue(header.column.id))
                                                                                                .filter((val): val is string => typeof val === "string") // aseguras strings
                                                                                                .filter((value, index, self) => self.indexOf(value) === index) // únicos
                                                                                                .filter(value => {
                                                                                                    const inputValue = filterInputValues[header.column.id];
                                                                                                    if (typeof inputValue !== "string") return true; // solo filtras si es string
                                                                                                    return value.toLowerCase().startsWith(inputValue.toLowerCase());
                                                                                                })
                                                                                                .map((value, index) => (
                                                                                                    <button
                                                                                                        key={index}
                                                                                                        type="button"
                                                                                                        onClick={(e) =>
                                                                                                            handleOnClickButtonCommonValuesFilter(e, value, header.column)
                                                                                                        }
                                                                                                    >
                                                                                                        <small>{value}</small>
                                                                                                    </button>
                                                                                                ))}

                                                                                        </div>
                                                                                    </div>
                                                                                </div>
                                                                            )
                                                                        }
                                                                        {
                                                                            header.column.columnDef.meta?.type === "number" && (
                                                                                <div>
                                                                                    {header.column.columnDef.meta?.mode === "range"
                                                                                        ? (
                                                                                            <div>
                                                                                                <NumberSlice
                                                                                                    min={1} // el minimo debe ser uno
                                                                                                    max={Math.max(
                                                                                                        ...table
                                                                                                            .getFilteredRowModel()
                                                                                                            .rows
                                                                                                            .map(row => Number(row.getValue(header.column.id))) // convertir explícitamente a número
                                                                                                            .filter(value => !isNaN(value)) // eliminar los NaN resultantes de conversiones inválidas
                                                                                                    )}
                                                                                                    step={1}
                                                                                                    value={filterInputValues[header.column.id] as ObjectNumericFilter}
                                                                                                    label={header.id}
                                                                                                    onChange={(val) => handlerOnChangeInputTextFilterColumn(val, header.column)}
                                                                                                    mode={header.column.columnDef.meta?.mode}
                                                                                                />
                                                                                            </div>
                                                                                        ) : (
                                                                                            <div>
                                                                                                <NumberSlice
                                                                                                    min={1} // el minimo debe ser uno
                                                                                                    max={Math.max(
                                                                                                        ...table
                                                                                                            .getFilteredRowModel()
                                                                                                            .rows
                                                                                                            .map(row => Number(row.getValue(header.column.id))) // convertir explícitamente a número
                                                                                                            .filter(value => !isNaN(value)) // eliminar los NaN resultantes de conversiones inválidas
                                                                                                    )}
                                                                                                    step={1}
                                                                                                    value={filterInputValues[header.column.id] as ObjectNumericFilter}
                                                                                                    label={header.id}
                                                                                                    onChange={(value) => handlerOnChangeInputTextFilterColumn(value, header.column)}
                                                                                                    mode="single"
                                                                                                />
                                                                                            </div>
                                                                                        )
                                                                                    }
                                                                                </div>
                                                                            )
                                                                        }
                                                                        {
                                                                            header.column.columnDef.meta?.type === "date" && (
                                                                                <div>
                                                                                    {
                                                                                        header.column.columnDef.meta?.mode === "range"
                                                                                            ? (
                                                                                                <div>
                                                                                                    <DateSlicer
                                                                                                        value={filterInputValues[header.column.id] as ObjectDateFilter}
                                                                                                        label={header.id}
                                                                                                        onChange={(val) => handlerOnChangeInputTextFilterColumn(val, header.column)}
                                                                                                        mode={header.column.columnDef.meta?.mode}
                                                                                                    />
                                                                                                </div>
                                                                                            ) : (
                                                                                                <div>
                                                                                                    <DateSlicer
                                                                                                        value={filterInputValues[header.column.id] as ObjectDateFilter}
                                                                                                        label={header.id}
                                                                                                        onChange={(value) => handlerOnChangeInputTextFilterColumn(value, header.column)}
                                                                                                        mode={header.column.columnDef.meta?.mode}
                                                                                                    />
                                                                                                </div>
                                                                                            )
                                                                                    }
                                                                                </div>
                                                                            )
                                                                        }
                                                                        {
                                                                            header.column.columnDef.meta?.type === "boolean" && (
                                                                                <div>
                                                                                    <BooleanInput
                                                                                        value={filterInputValues[header.column.id] as BooleanFilter}
                                                                                        options={header.column.columnDef.meta?.booleanLabels ?? ["false", "true"]}
                                                                                        onChange={(value) => handlerOnChangeInputTextFilterColumn(value, header.column)}
                                                                                        label={header.id}
                                                                                    />
                                                                                </div>
                                                                            )
                                                                        }
                                                                        {
                                                                            header.column.columnDef.meta?.type === "enum" && (
                                                                                <div>
                                                                                    <EnumSelectInput
                                                                                        options={header.column.columnDef.meta.options || []}
                                                                                        value={filterInputValues[header.column.id] as EnumFilter}
                                                                                        onChange={(value) => handlerOnChangeInputTextFilterColumn(value, header.column)}
                                                                                        label="Role"
                                                                                    />
                                                                                </div>
                                                                            )
                                                                        }
                                                                        <button
                                                                            // disabled={(String(filterInputValues[header.column.id]) === "")}
                                                                            onClick={(e) => handlerOnClickButtonAddFilterColumn(e, header.column)}
                                                                        >
                                                                            Add filter
                                                                        </button>
                                                                    </div>
                                                                )
                                                            }
                                                        </div>
                                                    </div>
                                                )
                                            }
                                        </div>
                                    </th>
                                ))}
                            </tr>
                        ))}
                    </thead>
                    <tbody>
                        {table.getRowModel().rows.length > 0
                            ? (
                                table.getRowModel().rows.map((row) => (
                                    <tr key={row.id}>

                                        {row.getVisibleCells().map((cell) => (
                                            <td key={cell.id}>
                                                {flexRender(
                                                    cell.column.columnDef.cell,
                                                    cell.getContext()
                                                )}
                                            </td>
                                        ))}
                                    </tr>
                                ))
                            )
                            : (
                                <tr>
                                    <td colSpan={table.getAllColumns().length}>
                                        No results.
                                    </td>
                                </tr>
                            )
                        }
                    </tbody>
                    <tfoot>
                        <tr >
                            <td colSpan={table.getAllColumns().length}>
                                <div
                                    style={
                                        {
                                            display: "flex",
                                            flexDirection: "row"
                                        }
                                    }
                                >
                                    <div
                                        style={
                                            {
                                                display: "flex",
                                                flexDirection: "row"
                                            }
                                        }
                                    >
                                        <small>
                                            {`${selectedRows.length} rows selected`}
                                        </small>
                                        {selectedRows.length > 0 && (
                                            <button
                                                onClick={deleteRowsSelected}
                                            >
                                                Delete
                                            </button>
                                        )}
                                    </div>
                                    <PaginationControls
                                        table={table}
                                        onChange={onChangeSelectRowsPerPage}
                                    />
                                </div>
                            </td>
                        </tr>

                    </tfoot>
                </table>

            </div>
        </div >
    );
};

export default GenericTable;
