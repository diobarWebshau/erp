import {
    useState, useRef,
} from "react";
import type {
    ChangeEvent,
    MouseEvent,
    RefObject
} from "react"
import type {
    ColumnDef,
    Row,
    Table,
    Column,
    HeaderContext,
    VisibilityState,
    RowSelectionState,
    SortingState,
    Updater,
    PaginationState,
    ColumnFiltersState,
    ColumnFilter,
    ColumnSort,
} from "@tanstack/react-table";

import {
    getFilteredRowModel,
    getPaginationRowModel,
    getSortedRowModel,
    getCoreRowModel,
    useReactTable,
} from "@tanstack/react-table";

import ColumnVisibilityPopover
    from "./components/table/column-visibility-popover/ColumnVisibilityPopover";
import { useClickOutside }
    from "./customHooks/useClickOutside";
import RowOptionsToggler
    from "./components/table/row-options-toggler/RowOptionsToggler copy";
import startsWithFilter
    from "./filters/string/startsWithFilter";
import type {
    ColumnTypeDataFilter, ObjectDateFilter,
    ObjectNumericFilter, BooleanFilter,
    EnumFilter, TopButtonAction
} from "./types";
import betweenNumberFilter
    from "./filters/number/betweenNumberFilter";
import equalsNumberFilter
    from "./filters/number/equalsNumberFilter";
import betweenDateFilter
    from "./filters/date/betweenDateFilter";
import equalsDateFilter
    from "./filters/date/equalsDateFilter";
import formatDateToDMY
    from "./utils/formatDateToDMY";
import equalsBooleanFilter
    from "./filters/boolean/equalsBooleanFilter";
import GeneratorHeaderTable
    from "./components/table/generator-header-table/GeneratorHeaderTable";
import { FiltersPopoverList }
    from "./components/table/filter-popover-list/FilterPopoverList";
import SortsPopoverList
    from "./components/table/sort-popover-list/sortsPopoverList";
import TableFooterControls
    from "./components/table/table-footer-controls/TableFooterControls";
import GeneratorBodyTable
    from "./components/table/generator_body-table/GeneratorBodyTable";
import type {
    RowAction, WrappedRowAction
} from "./types";
import {
    Ellipsis
} from "lucide-react"
import stylesModules
    from "./GenericTable.module.css"

declare module '@tanstack/react-table' {
    interface ColumnMeta<TData extends unknown, TValue> {
        autoGenerated: boolean,
        type?: 'string' | 'number' | 'date' | 'boolean' | 'enum',
        mode?: 'range' | 'single',
        booleanLabels?: [string, string],
        options?: string[],
        hidden?: boolean,
        isMetaColumn?: boolean,
        typeText?: "password" | "email" | "text",
        numberType?: "integer" | "decimal",
    }
}

interface GenericTableProps<T> {
    modelName: string;
    columns: ColumnDef<T>[];
    data: T[];
    onDeleteSelected: (datas: T[]) => void;
    typeRowActions?: "ellipsis" | "icon";
    rowActions: RowAction<T>[];
    extraButtons?: TopButtonAction<T>[];
    enableFilters?: boolean;
    enableSorting?: boolean;
    enableViews?: boolean;
    enablePagination?: boolean;
    enableRowSelection?: boolean;
    enableOptionsColumn?: boolean;
    noResultsMessage?: string;
}


const GenericTable = <T,>({
    columns,
    data,
    onDeleteSelected,
    rowActions,
    extraButtons,
    typeRowActions = "ellipsis",
    enableFilters = true,
    enableSorting = true,
    enableViews = true,
    enablePagination = true,
    enableRowSelection = true,
    enableOptionsColumn = true,
    noResultsMessage = "No results.",
}: GenericTableProps<T>) => {

    /** LÓGICA PARA SELECCIÓN DE FILAS
     *
     * @types
     *  - @RowSelectionState
     *      representa el estado de selección de las filas. Es un objeto en el que las claves son 
     *      los IDs de las filas seleccionadas y los valores son booleanos. 
     *      Se usa generalmente con `useState` y se pasa a `useReactTable`.
     *
     *
     * @options
     *  - @enableRowSelection
     *      opción booleana o función que define si se puede seleccionar alguna o todas las filas. 
     *      Se pasa a `useReactTable`. Si es `true`, habilita la selección en todas las filas.
     *
     *  - @onRowSelectionChange
     *      se ejecuta cada vez que el usuario selecciona o deselecciona una fila.
     *      Se utiliza para sincronizar el estado `rowSelection` con `setRowSelection`.
     *
     * @requirements @row
     *  - @getIsSelected
     *      método que devuelve `true` si la fila actual está seleccionada.
     *  - @toggleSelected
     *      método que alterna el estado de selección de la fila actual.
     *  - @getCanSelect
     *      método que indica si una fila puede ser seleccionada (por ejemplo, si se deshabilita).
     *  - @getToggleSelectedHandler
     *      
     * 
     * @requirements @table
     *  - @getSelectedRowModel
     *      método de la tabla para obtener todas las filas seleccionadas. Devuelve un modelo 
     *      de filas que puede ser iterado o transformado según sea necesario.
     *  - @getIsAllPageRowsSelected
     *  - @getToggleAllPageRowsSelectedHandler
     *
     *
     * EJEMPLO DE CICLO:
     * - El usuario hace clic en la checkbox de una fila.
     * - Se dispara `onRowSelectionChange` → actualiza el estado `rowSelection` 
     *   con `setRowSelection`.
     * - La tabla evalúa internamente el nuevo estado y `getSelectedRowModel` 
     *   calcula las filas seleccionadas.
     * - La interfaz se re-renderiza con las filas seleccionadas actualizadas.
     */

    const [rowSelection, setRowSelection] =
        useState<RowSelectionState>({});

    /** declaracion de la columna para seleccion
     * 
     * @params
     *     -- @id
     *          -- Define un identificador único de la columna. Es obligatorio si no 
     *             usas accessorKey ni accessorFn. Útil para columnas virtuales (como
     *             checkboxes, acciones, etc.).
     * 
     *     -- @accessKey
     *          -- Define la clave del objeto data que se va a mostrar en esta columna.
     *             Es la forma más simple y común de mapear datos reales.
     * 
     *     -- @header
     *          -- renderizacion en el encabezado de la columna en la tabla
     *          -- se envia el contexto del header que tiene un objeto que referencia 
     *             al objeto completo de la tabla, porque este checkbox controla la 
     *             seleccion de todas las filas
     *          -- Puede ser una cadena, un componente JSX o una función con acceso al
     *             column y al table.
     *     -- @cell
     *          -- renderizacion en cada celda de la columna en la tabla
     *          -- se envia unicamente la row, porque solo controla la seleccion de esa row
     *          -- Define cómo se muestra el contenido de cada celda de la columna(Puede 
     *             ser una cadena, un componente JSX o una función).
     *          -- puede recibir { row, getValue, column, table }.
     *     -- @footer
     *          -- (igual que header) Define lo que se renderiza como pie de columna.
     *     -- @enableSorting (boolean)
     *          -- Si la columna puede o no ordenarse. Por defecto: true.
     *     -- @enableHiding (boolean)
     *          -- Permite o impide ocultar la columna desde un control de columnas.
     *     -- @enableColumnFilter
     *          -- Controla si esta columna puede tener filtros aplicados.
     *          -- Por defecto: true.
     *     
     */
    const selectionColumn: ColumnDef<T> = {
        id: "select",
        header: (ctx: HeaderContext<T, unknown>) => {
            const { table } = ctx;
            return (
                <input
                    type="checkbox"
                    checked={table.getIsAllPageRowsSelected()}
                    onChange={table.getToggleAllPageRowsSelectedHandler()}
                />
            );
        },
        cell: ({ row }: { row: Row<T> }) => (
            <input
                type="checkbox"
                checked={row.getIsSelected()}
                onChange={row.getToggleSelectedHandler()}
            />
        ),
        enableSorting: false,
        enableHiding: false,
        meta: {
            autoGenerated: false,
            isMetaColumn: true,
        }
    }




    /** LOGICA PARA COLUMNA OPTIONS PARA LAS ROWS
     * 
    */

    const [isActiveRowPopover, setIsActiveRowPopover] = useState<string | null>(null);
    const optionsPopoverRef = useRef<HTMLDivElement>(null);
    const optionsPopoverTriggerRef = useRef<HTMLButtonElement>(null);
    const toggleRowPopover = (rowId: string) => {
        setIsActiveRowPopover((prev) => (prev === rowId ? null : rowId));
    };
    // Función para limpiar selección y cerrar popover
    const closePopoverAndClearSelection = (table: Table<T>) => {
        table.setRowSelection({});
        setIsActiveRowPopover(null);
    };



    const wrapRowActions = (
        actions: RowAction<T>[],
        rowData: T,
        table: Table<T>
    ): WrappedRowAction[] => {
        return actions.map((action) => ({
            ...action,
            onClick: () => {
                closePopoverAndClearSelection(table);
                action.onClick(rowData);
            },
            disabled: action.disabled ? () => action.disabled!(rowData) : undefined,
        }));
    };


    const deleteRowsSelected = () => {
        const datas: T[] = selectedRows.map(row => row.original);
        onDeleteSelected(datas as T[]);
        setRowSelection({});
    }

    const optionsColumn: ColumnDef<T> = {
        id: "options",
        header: typeRowActions === "icon" ? "Actions" : () => null, // no renderiza nada, sera una columna  sin placeholder
        cell: ({ row, table }: { row: Row<T>, table: Table<T> }) => (
            <div
                style={
                    { position: "relative" }
                }
            >
                {
                    typeRowActions === "ellipsis" ? (
                        <div>
                            <button
                                ref={optionsPopoverTriggerRef}
                                style={
                                    {
                                        border: "none",
                                        background: "transparent",
                                        cursor: "pointer"
                                    }
                                }
                                onClick={() => { toggleRowPopover(row.id) }}
                            >
                                <Ellipsis size={15} />
                            </button>
                            {
                                isActiveRowPopover === row.id ? (
                                    <RowOptionsToggler
                                        ref={optionsPopoverRef}
                                        actions={wrapRowActions(rowActions, row.original, table)}
                                    />
                                ) : null
                            }
                        </div>
                    )
                        : (
                            <div
                                style={
                                    {
                                        display: "flex",
                                        flexDirection: "row",
                                        gap: "5px",
                                        alignItems: "center",
                                        justifyContent: "center"
                                    }
                                }
                            >
                                {rowActions.map((action, index) => (
                                    <button
                                        style={
                                            {
                                                border: "none",
                                                background: "transparent",
                                                cursor: "pointer"
                                            }
                                        }
                                        type="button"
                                        key={index}
                                        onClick={() => {
                                            action.onClick(row.original);
                                        }}
                                        disabled={action.disabled ? action.disabled(row.original) : false}
                                    >
                                        {action.icon}
                                    </button>
                                ))}
                            </div>
                        )
                }
            </div >
        ),
        enableSorting: false,
        enableHiding: false,
        meta: {
            autoGenerated: false,
            isMetaColumn: true,
        }
    }
    useClickOutside(
        [optionsPopoverRef, optionsPopoverTriggerRef],
        () => setIsActiveRowPopover(null)
    );

    /** LÓGICA PARA PAGINACIÓN
     *
     * @types
     *  - @PaginationState  
     *      representa el estado actual de la paginación. Es un objeto con 
     *      dos propiedades:
     *          `pageIndex` (índice de la página actual, comenzando desde 0) y 
     *          `pageSize` (número de filas por página). Este estado debe ser
     *            controlado con `useState`.
     *
     * @functions
     *  - @getPaginationRowModel  
     *      función que se pasa a `useReactTable` para obtener el modelo de filas 
     *      correspondiente a la página actual, según el `PaginationState`.
     *
     * @options
     *  - @getPaginationRowModel  
     *      opción que se proporciona al crear la tabla con `useReactTable` 
     *      para habilitar el modelo de paginación. Sin esto, la tabla no sabrá 
     *      cómo segmentar las filas.
     *  - @onPaginationChange  
     *      función que se ejecuta cada vez que cambia la página o el tamaño de página. 
     *      Se utiliza para actualizar el estado `pagination` con `setPagination`.
     *
     * @requirements @table
     *  - @getCanNextPage  
     *      retorna `true` si se puede avanzar a la siguiente página.
     *  - @getCanPreviousPage  
     *      retorna `true` si se puede retroceder a la página anterior.
     *  - @nextPage  
     *      método que avanza el estado de paginación a la siguiente página.
     *  - @previousPage  
     *      método que retrocede a la página anterior.
     *  - @setPageIndex  
     *      establece manualmente el índice de la página actual.
     *  - @setPageSize  
     *      establece cuántas filas se deben mostrar por página.
     *  - @getPageCount  
     *      devuelve el número total de páginas calculadas según el total de filas 
     *      y el tamaño de página.
     *
     * EJEMPLO DE CICLO:
     * - El usuario hace clic en el botón "Siguiente".
     * - Se ejecuta `nextPage`, lo que incrementa el `pageIndex`.
     * - Se dispara `onPaginationChange` → actualiza el estado `pagination`.
     * - `getPaginationRowModel` calcula las filas correspondientes a la nueva página.
     * - La tabla se re-renderiza mostrando solo las filas de esa página.
     */

    const [pagination, setPagination] = useState<PaginationState>({
        pageIndex: 0,     // <-- aquí defines la página inicial
        pageSize: 5      // número de elementos por página
    });

    const onChangeSelectRowsPerPage = (e: ChangeEvent<HTMLSelectElement>) => {
        table.setPageSize(Number(e.target.value));
    }


    /** LÓGICA PARA ORDENAR (SORTEAR) COLUMNAS
     *
     * @types
     *  - @SortingState 
     *      representa el estado actual de ordenamiento de la tabla. 
     *      Es un arreglo de objetos que indican qué columna está siendo
     *      ordenada y en qué dirección (ascendente o descendente).
     *  - @ColumnDef 
     *      definición de las columnas, incluyendo la configuración que
     *      permite que una columna sea ordenable, como la propiedad 
     *      `enableSorting`.
     *
     * @functions
     *  - @getSortedRowModel
     *      función que se utiliza para aplicar el ordenamiento a las filas
     *      de la tabla, basada en el estado de `sorting`. Esta función debe
     *      ser incluida en el constructor `useReactTable` para que la tabla
     *      pueda calcular y renderizar las filas ya ordenadas.
     *
     * @options
     *  - @getSortedRowModel
     *      se pasa como una opción en `useReactTable` para que la tabla sepa
     *      cómo obtener y manejar las filas ordenadas. Internamente, reordena
     *      las filas según la configuración actual de `sorting`.
     *  - @onSortingChange
     *      función que se ejecuta cada vez que se cambia el ordenamiento (por
     *      ejemplo, al hacer clic en un encabezado de columna). Generalmente se
     *      usa para actualizar el estado `sorting` con `setSorting`.
     * 
     * @requirements @column  
     *  - @getIsSorted  
     *      método que indica si la columna está ordenada y en qué dirección 
     *      ("asc", "desc" o false).
     *  - @toggleSorting  
     *      método que permite alternar el estado de ordenamiento de una 
     *      columna.
     *  - @setSorting  
     *      función utilizada para modificar el estado global de ordenamiento 
     *      (`sorting`) directamente.
     *
     * EJEMPLO DE CICLO:
     * - El usuario da clic en un encabezado de columna.
     * - Se dispara `onSortingChange` → actualiza el estado `sorting`.
     * - El nuevo estado activa `getSortedRowModel` → reorganiza las filas.
     * - La tabla se re-renderiza con las filas ordenadas.
     */

    // Estado que guarda el sorting aplicado en la tabla
    const [sorting, setSorting] = useState<SortingState>([]);
    // Estado temporal para cambios en el select antes de confirmar
    // const [tempSorting, setTempSorting] = useState<SortingState>([]);
    const [isVisibleSortsListPopover, setIsVisibleSortsListPopover] =
        useState<boolean>(false);
    const filterSortPopoverRef = useRef<HTMLDivElement>(null);
    const triggerRefSortsList = useRef<HTMLButtonElement>(null);

    const handlerOnClickButtonSortsList = (e: MouseEvent<HTMLButtonElement>) => {
        e.preventDefault();
        setIsVisibleSortsListPopover((prev) => !prev);
    }

    useClickOutside(
        [
            filterSortPopoverRef,
            triggerRefSortsList
        ],
        () => setIsVisibleSortsListPopover(false)
    );

    const toggleCycleSortingColumn = (column: Column<T>) => {
        column.toggleSorting(false);
    }




    /**
     * Lógica de ordenamiento cíclico: ascendente → descendente → sin orden
     * @param updater - Puede ser una función que recibe el estado actual o un nuevo estado directo
     * @param sorting - Estado actual de ordenamiento
     * @param setSorting - Setter del estado de ordenamiento (como setState)
     */
    const handleTriStateSortingChange = (updater: Updater<SortingState>) => {
        const next: SortingState =
            typeof updater === "function" ? updater(sorting) : updater;
        const last: ColumnSort | undefined = next.at(-1);
        if (!last) return;

        setSorting((prev) => {
            const exists: ColumnSort | undefined =
                prev.find((s) => s.id === last.id);

            if (exists?.desc === true) {
                return prev.filter((s) => s.id !== last.id);
            }

            if (exists?.desc === false) {
                return prev.map((s) =>
                    s.id === last.id ? { ...s, desc: true } : s
                );
            }

            return [...prev, { id: last.id, desc: false }];
        });
    }

    /** LÓGICA PARA EL FILTRADO
     *
     * @types
     *  - @ColumnFiltersState  
     *      representa el estado del filtrado por columna. Es un arreglo de objetos, 
     *      donde cada objeto contiene `id` (la columna) y `value` (el valor del filtro).  
     *      Este estado se debe controlar con `useState` y pasarse a `useReactTable`.
     *      El orden en el arreglo columnFilters determina el orden en el que se aplican
     *      los filtros.
     *
     * @functions
     *  - @getFilteredRowModel  
     *      función que genera un modelo de filas ya filtradas en base a los filtros activos.  
     *      Es clave para que la tabla muestre los datos según los criterios de filtrado.
     *
     * @options
     *  - @onColumnFiltersChange  
     *      se dispara cada vez que un filtro de columna cambia.  
     *      Sirve para actualizar el estado `columnFilters` con `setColumnFilters`.
     * 
     *  - @getFilteredRowModel  
     *      opción que se pasa al crear la tabla con `useReactTable` para aplicar el filtrado.
     *
     * @requirements @table
     *  - @getCoreRowModel  
     *      necesario para que `getFilteredRowModel` tenga acceso a todas las filas base antes
     *      de aplicar filtros.
     *  - @getFilteredRowModel  
     *      retorna las filas que cumplen con los filtros activos.
     *
     * @requirements @column
     *  - @enableColumnFilter (opcional)  
     *      se puede usar para habilitar o deshabilitar el filtrado por columna individual.
     *  - @filterFn (opcional)  
     *      permite definir una función de filtrado personalizada para esa columna.  
     *      Si no se proporciona, se usará la función por defecto (por ejemplo, incluye texto).
     *
     *
     * EJEMPLO DE USO:
     * - El usuario escribe texto en un input de filtro.
     * - Se ejecuta `onColumnFiltersChange` → actualiza `columnFilters` con `setColumnFilters`.
     * - La tabla evalúa `columnFilters` y aplica `filterFn` por cada columna filtrada.
     * - `getFilteredRowModel` produce un nuevo conjunto de filas filtradas.
     * - La tabla se re-renderiza mostrando solo las filas que cumplen con los filtros.
     */

    const [filterInputValues, setFilterInputValues] =
        useState<Record<string, ColumnTypeDataFilter>>({});
    const [isVisibleFilterPopover, setIsVisibleFilterPopover] = useState<string | null>(null);
    const [isVisibleFiltersListPopover, setIsVisibleFiltersListPopover] =
        useState<boolean>(false);
    const filterListPopoverRef = useRef<HTMLDivElement>(null);
    const triggerRefFilterList = useRef<HTMLButtonElement>(null);
    const [columnFilters, setColumnFilters] =
        useState<ColumnFiltersState>([]);
    const filterPopoverRef = useRef<HTMLDivElement>(null);

    useClickOutside(
        [
            filterListPopoverRef,
            triggerRefFilterList
        ],
        () => setIsVisibleFiltersListPopover(false)
    );
    /*
        Se creó un objeto con referencias para cada botón de filtro de columna (un Record con refs dinámicos).
        Al renderizar cada botón, se guarda su referencia en ese objeto. En useClickOutside se pasan todas esas
        referencias (el popover + todos los botones) como un array para que el hook pueda verificar si el clic 
        fue fuera de todos esos elementos.Si el clic es fuera, se cierra el popover (se llama a 
        setIsVisibleFilterPopover(null)).
    */
    const filterTriggerRefs =
        useRef<Record<string, HTMLButtonElement | null>>({});

    const handlerOnClickButtonFiltersList = (e: MouseEvent<HTMLButtonElement>) => {
        e.preventDefault();
        setIsVisibleFiltersListPopover((prev) => !prev);
    }

    const handlerOnClickButtonFilter = (
        e: MouseEvent<HTMLButtonElement>,
        column: Column<T>,
    ) => {
        e.preventDefault();

        if (isVisibleFilterPopover === column.id) {
            setIsVisibleFilterPopover(null);
        } else {
            let emptyFilterValue: ColumnTypeDataFilter;

            switch (column.columnDef.meta?.type) {
                case "string":
                    emptyFilterValue = "";
                    break;
                case "number":
                    emptyFilterValue = { min: undefined, max: undefined };
                    break;
                case "date":
                    emptyFilterValue = { start: "", end: "" };
                    break;
                case "boolean":
                    emptyFilterValue = undefined;
                    break;
                case "enum":
                    emptyFilterValue = undefined;
                    break;
                default:
                    emptyFilterValue = "";
            }

            setFilterInputValues((prev) => ({
                ...prev,
                [column.id]: emptyFilterValue as ColumnTypeDataFilter,
            }));
            setIsVisibleFilterPopover(column.id);
        }
    };

    useClickOutside(
        [
            filterPopoverRef,
            ...(
                Object.values(filterTriggerRefs.current)
                    .map(
                        (el) => ({ current: el })
                    )
            )
        ],
        () => setIsVisibleFilterPopover(null)
    );

    const handlerOnClickButtonAddFilterColumn = (
        e: React.MouseEvent<HTMLButtonElement>,
        column: Column<T>
    ) => {
        e.preventDefault();
        let valueInput =
            filterInputValues[column.id] as ColumnTypeDataFilter;
        let withoutCurrent: ColumnFilter[] =
            columnFilters.filter((f) => f.id !== column.id);
        switch (column.columnDef.meta?.type) {
            case "string":
                valueInput = valueInput as string;
                if (valueInput.trim() !== "")
                    withoutCurrent =
                        [...withoutCurrent,
                        { id: column.id, value: valueInput }];
                break;
            case "number":
                valueInput = valueInput as ObjectNumericFilter;
                if (valueInput.max !== undefined
                    || valueInput.min !== undefined)
                    withoutCurrent =
                        [
                            ...withoutCurrent,
                            {
                                id: column.id,
                                value: {
                                    min: valueInput.min,
                                    max: valueInput.max
                                }
                            }
                        ];
                break;
            case "date":
                valueInput = valueInput as ObjectDateFilter;
                if (valueInput.start !== "" || valueInput.end !== "")
                    withoutCurrent =
                        [
                            ...withoutCurrent,
                            {
                                id: column.id,
                                value: {
                                    start: formatDateToDMY(valueInput.start),
                                    end: (valueInput.end !== undefined)
                                        ? formatDateToDMY(valueInput.end)
                                        : valueInput.end
                                }
                            }
                        ];
                break;
            case "boolean":
                valueInput = valueInput as BooleanFilter;
                if (valueInput !== undefined)
                    withoutCurrent =
                        [
                            ...withoutCurrent,
                            {
                                id: column.id,
                                value: valueInput
                            }
                        ];
                break;
            case "enum":
                valueInput = valueInput as EnumFilter;
                if (valueInput !== undefined)
                    withoutCurrent =
                        [
                            ...withoutCurrent,
                            {
                                id: column.id,
                                value: valueInput
                            }
                        ];
                break;
        }
        setColumnFilters(withoutCurrent);
        setIsVisibleFilterPopover(null);
    };


    const getValueFieldColumnFilter = (columnId: string): any => {
        const column =
            columnFilters.find((columnFilter) =>
                columnFilter.id == columnId);
        return column?.value ?? "";
    }

    const asignFilterFnToColumns = (columns: ColumnDef<T>[]): ColumnDef<T>[] => {
        const appliedFilterTypeToColumn: ColumnDef<T>[] = columns.map((col) => {
            switch (col.meta?.type) {
                case "string":
                    return {
                        ...col,
                        filterFn: startsWithFilter,
                    };
                case "number":
                    switch (col.meta?.mode) {
                        case "range":
                            return {
                                ...col,
                                filterFn: betweenNumberFilter,
                            };
                        case "single":
                            return {
                                ...col,
                                filterFn: equalsNumberFilter,
                            };
                        default:
                            return col;
                    }
                case "date":
                    switch (col.meta?.mode) {
                        case "range":
                            return {
                                ...col,
                                filterFn: betweenDateFilter,
                            };
                        case "single":
                            return {
                                ...col,
                                filterFn: equalsDateFilter,
                            };
                        default:
                            return col;
                    }
                case "boolean":
                    return {
                        ...col,
                        filterFn: equalsBooleanFilter
                    }
                case "enum":
                    return {
                        ...col,
                        filterFn: startsWithFilter
                    }
                default:
                    return col;
            }
        });
        return appliedFilterTypeToColumn;
    }

    const formattedColumns = (column: ColumnDef<T>[]): ColumnDef<T>[] => {
        const columnFormatted: ColumnDef<T>[] = column.map((col) => {
            if (col.meta?.type === "date") {
                return {
                    ...col,
                    cell: ({ getValue }) => {
                        return formatDateToDMY(getValue<string>());
                    },
                };
            } else {
                return col;
            }
        })
        return columnFormatted;
    }

    // const asignRenderBooleanColumn = (column: ColumnDef<T>[]): ColumnDef<T>[] => {
    //     const columnFormatted: ColumnDef<T>[] = column.map((col) => {
    //         if (col.meta?.type === "boolean") {
    //             const flag: boolean = !col.meta.options;
    //             if (flag) {
    //                 col.meta.options = ["false", "true"];
    //             }
    //             return {
    //                 ...col,
    //                 cell: ({ getValue }) => {
    //                     const options: string[] = col.meta?.options ?? [];
    //                     if (!flag && options.length > 0) {
    //                         return (<div>
    //                             {options[Number(getValue<boolean>())]}
    //                         </div>)

    //                     } else {
    //                         return <div>
    //                             {getValue<boolean>().toString()}
    //                         </div>
    //                     }
    //                 },
    //             };
    //         }

    //         return col;
    //     });

    //     return columnFormatted;
    // };

    const asignRenderBooleanColumn = <T,>(columns: ColumnDef<T>[]): ColumnDef<T>[] => {
        return columns.map((col) => {
            if (col.meta?.type === "boolean") {
                // Clonamos meta para no mutar original
                const meta = { ...col.meta };

                // Si no tiene booleanLabels, asignamos las por defecto y actualizamos meta
                if (!meta.booleanLabels) {
                    meta.booleanLabels = ["false", "true"];
                }
                return {
                    ...col,
                    meta, // actualizamos meta con booleanLabels garantizados
                    cell: ({ getValue }) => {
                        const boolValue = getValue<boolean>();
                        const display = meta.booleanLabels![Number(boolValue)];
                        return <div>{display}</div>;
                    },
                    filterFn: (row, columnId, filterValue) => {
                        const rawValue = row.getValue(columnId);
                        const rendered = meta.booleanLabels![Number(rawValue)];
                        return rendered === filterValue;
                    },
                };
            }
            return col;
        });
    };




    const processedColumns = () => {
        const columnsWithFilters = asignFilterFnToColumns(columns);
        const columnsWithBoolean = asignRenderBooleanColumn(columnsWithFilters);
        const columnsFormatted = formattedColumns(columnsWithBoolean);
        const selectionColumnsEnable: ColumnDef<T>[] = enableRowSelection ? [selectionColumn] : [];
        const optionsColumnsEnable: ColumnDef<T>[] = enableOptionsColumn ? [optionsColumn] : [];
        return [...selectionColumnsEnable, ...columnsFormatted, ...optionsColumnsEnable];
    }

    const getStateVisibilityColumns = <T,>(columns: ColumnDef<T>[]) => {
        const visibilityState: Record<string, boolean> = Object.fromEntries(
            columns.map((col) => {
                const key =
                    'id' in col && col.id
                        ? col.id
                        : 'accessorKey' in col && col.accessorKey
                            ? String(col.accessorKey)
                            : ''; // fallback si no tiene ni id ni accessorKey

                return [key, !col.meta?.hidden];
            }).filter(([key]) => key !== '') // eliminamos columnas sin clave
        );

        return visibilityState;
    };



    // const getCommonValuesFilters = (columnId: string, row: Row<T>) => {
    //     const value = row.getValue(columnId);
    //     const inputValue = filterInputValues[columnId]?.toLowerCase() ?? "";

    //     if (typeof value === "string") {
    //         return value.toLowerCase().startsWith(inputValue);
    //     }

    //     return false;
    // };

    // Actualizar el valor del input en el estado local
    const handlerOnChangeInputTextFilterColumn = (
        value: ColumnTypeDataFilter,
        column: Column<T>
    ) => {
        switch (column.columnDef.meta?.type) {
            case "string":
                const stringValue = value as string;
                setFilterInputValues((prev) => ({
                    ...prev,
                    [column.id]: stringValue as ColumnTypeDataFilter,
                }));
                break;
            case "number":
                switch (column.columnDef.meta?.mode) {
                    case "range": {
                        const numberValue = value as ObjectNumericFilter;
                        const filter: Partial<ObjectNumericFilter> = {
                            min: undefined,
                            max: undefined,
                        };
                        const minValue = Number(numberValue?.min);
                        const maxValue = Number(numberValue?.max);
                        if (minValue !== undefined && !isNaN(minValue))
                            filter.min = minValue;
                        if (maxValue !== undefined && !isNaN(maxValue))
                            filter.max = maxValue;
                        setFilterInputValues((prev) => ({
                            ...prev,
                            [column.id]: filter as ColumnTypeDataFilter,
                        }));
                        break;
                    }
                    case "single": {
                        const numberValue = value as ObjectNumericFilter;
                        const filter: Partial<ObjectNumericFilter> = {
                            min: undefined,
                        };
                        const numValue = Number(numberValue?.min);
                        if (!isNaN(numValue))
                            filter.min = numValue;
                        setFilterInputValues((prev) => ({
                            ...prev,
                            [column.id]: filter as ColumnTypeDataFilter,
                        }));
                        break;
                    }
                }
                break;
            case "date":
                switch (column.columnDef.meta?.mode) {
                    case "range": {
                        const dateValue: ObjectDateFilter =
                            value as ObjectDateFilter;
                        const filter = {
                            start: "",
                            end: ""
                        } as Partial<ObjectDateFilter>;
                        const startValue: string = dateValue?.start ?? "";
                        const endValue: string = dateValue?.end ?? "";
                        filter.start = startValue;
                        filter.end = endValue;
                        setFilterInputValues((prev) => ({
                            ...prev,
                            [column.id]: filter as ColumnTypeDataFilter,
                        }));
                        break;
                    }
                    case "single": {
                        const dateValue: ObjectDateFilter =
                            value as ObjectDateFilter;
                        const filter = {
                            start: "",
                        } as Partial<ObjectDateFilter>;
                        if (dateValue.start !== "")
                            filter.start = dateValue.start;
                        setFilterInputValues((prev) => ({
                            ...prev,
                            [column.id]: filter as ColumnTypeDataFilter,
                        }));
                        break;
                    }
                }
                break;
            case "boolean":
                const booleanValue = value as BooleanFilter;
                setFilterInputValues((prev) => ({
                    ...prev,
                    [column.id]: booleanValue as ColumnTypeDataFilter,
                }));
                break;
            case "enum":
                const enumValue = value as EnumFilter;
                setFilterInputValues((prev) => ({
                    ...prev,
                    [column.id]: enumValue as ColumnTypeDataFilter,
                }));
                break;
        }
    };

    const handleOnClickButtonCommonValuesFilter =
        (e: MouseEvent<HTMLButtonElement>, value: any, column: Column<T>) => {
            e.preventDefault();
            const valor = value as string;
            setFilterInputValues((prev) => ({
                ...prev,
                [column.id]: valor
            }));
        };

    const handleOnClickButtonDeleteFilter =
        (e: MouseEvent<HTMLButtonElement>, columnId: string) => {
            e.preventDefault();
            const withoutCurrent = columnFilters
                .filter((filter) => filter.id !== columnId);
            setColumnFilters(withoutCurrent);
        }

    /** LÓGICA PARA OCULTAR COLUMNAS
     *
     * @types
     *  - @VisibilityState  
     *      representa el estado actual de visibilidad de las columnas.
     *      Es un objeto donde las claves son los IDs de las columnas y
     *      los valores son booleanos que indican si la columna está visible (true) u oculta (false).
     *  - @ColumnDef  
     *      definición de las columnas, incluyendo la configuración que
     *      permite que una columna pueda ser ocultada, como `enableHiding`.
     *
     * @functions
     *  - @setColumnVisibility  
     *      función que permite establecer manualmente el estado de visibilidad
     *      de las columnas. Se puede usar para mostrar u ocultar columnas
     *      de forma programática.
     *
     * @options
     *  - @onColumnVisibilityChange  
     *      función que se ejecuta cuando se produce un cambio en la visibilidad
     *      de cualquier columna. Generalmente se usa para actualizar el estado
     *      `columnVisibility` con `setColumnVisibility`.
     *
     * @requirements @column  
     *  - @getIsVisible  
     *      método que devuelve un booleano indicando si la columna está actualmente visible.
     *  - @toggleVisibility  
     *      método que alterna (muestra u oculta) la visibilidad de una columna específica.
     *  - @setColumnVisibility  
     *      puede ser utilizado para establecer la visibilidad de múltiples columnas.
     *  - @getCanHide  
     *      Retorna un booleano que indica si la columna puede ocultarse, basado en `enableHiding`.
     *  - @getFacetedRowModel  
     *      Permite acceder a las filas visibles desde la perspectiva de esa columna,
     *      útil por ejemplo para obtener valores únicos o contar resultados de búsqueda.
     * 
     * @requirements @column 
     *  - @getAllColumns  
     *      Devuelve todas las columnas, visibles y no visibles. Ideal para listarlas con su visibilidad.
     *
     *  - @getVisibleLeafColumns 
     *      Devuelve solo las columnas visibles (hojas), útil para renderizado.
     *
     *  - @getState --> props -> @columnVisibility  
     *      Retorna el objeto actual de visibilidad (internamente manejado por TanStack).
     *      
     *  - @getFacetedRowModel
     *      Permite acceder a las filas visibles desde la perspectiva de esa columna,
     *      útil por ejemplo para obtener valores únicos o contar resultados de búsqueda.
     *       
     *      
     * EJEMPLO DE CICLO:
     * - El usuario interactúa con un input o checkbox para ocultar una columna.
     * - Se llama `column.toggleVisibility()` o se actualiza `setColumnVisibility`.
     * - Esto actualiza el estado `columnVisibility`.
     * - La tabla se re-renderiza ocultando o mostrando las columnas según el nuevo estado.
     */

    // state que guarda la visibilidad 
    const [columnVisibility, setColumnVisibility] =
        useState<VisibilityState>(getStateVisibilityColumns(columns));
    // state de la visibilidad del popover del boton de columnas
    const [isVisibleHidePopover, setIsVisibleHidePopover] =
        useState<boolean>(false);
    const [valueTextFieldColumnHide, setValueTextFieldColumnHide] =
        useState<string>("");
    const popoverRef: RefObject<HTMLDivElement | null>
        = useRef<HTMLDivElement>(null);
    const triggerRef: RefObject<HTMLButtonElement | null>
        = useRef<HTMLButtonElement>(null);
    const handlerClickButtonVisibblePopoverHideColumn =
        (e: React.MouseEvent<HTMLButtonElement>): void => {
            e.preventDefault();
            setValueTextFieldColumnHide("");
            setIsVisibleHidePopover((prev) => !prev);
        };
    const onChangeTextFieldColumnHide =
        (e: React.ChangeEvent<HTMLInputElement>): void => {
            setValueTextFieldColumnHide(e.target.value);
        };
    const handlerOnClickButtonHideColumn =
        (e: MouseEvent<HTMLButtonElement>, currentColumn: Column<T>): void => {
            e.preventDefault();
            // si es visible
            if (currentColumn.getIsVisible()) {
                // quitamos filtros activos
                if (currentColumn.getIsFiltered()) {
                    const withoutCurrent: ColumnFilter[] =
                        columnFilters.filter((prev) => prev.id !== currentColumn.id)
                    withoutCurrent && setColumnFilters(withoutCurrent);
                }
            }
            // cambiamos la visibilidad
            currentColumn.toggleVisibility();
        }

    useClickOutside(
        [popoverRef, triggerRef],
        () => {
            setIsVisibleHidePopover(false)
        }
    );


    /**
     * CONSTRUCTOR tanStack react table
     * @constructor useReactTable
     */

    const table: Table<T> = useReactTable({
        /*  Base data */
        data: data,
        columns: processedColumns(),
        getCoreRowModel: getCoreRowModel(),
        /* Hidden columns */
        onColumnVisibilityChange: setColumnVisibility,
        /* Sort columns */
        getSortedRowModel: getSortedRowModel(),
        // onSortingChange: setSorting,
        enableMultiSort: true, // <- permite múltiples ordenamientos simultáneos
        onSortingChange: handleTriStateSortingChange,
        /* Selection column or row */
        onRowSelectionChange: setRowSelection,
        /* Pagination  */
        getPaginationRowModel: getPaginationRowModel(),
        onPaginationChange: setPagination,
        /* Filter columns */
        onColumnFiltersChange: setColumnFilters,
        getFilteredRowModel: getFilteredRowModel(),
        /* Definir una id  por row, para que pueda identificar las filas unas de otras */
        getRowId: (row) => String((row as any).id), // usamos any, porque T no tiene declarado que tiene id
        /* State table */
        state: {
            pagination,
            columnVisibility,
            rowSelection,
            sorting,
            columnFilters
        },
    });



    /** EXTENSION DE LOGICA PARA SELECCIÓN DE FILAS
     * 
     * 
     */

    const selectedRows = table.getSelectedRowModel().rows;

    return (
        < div
            className={stylesModules.container}
        >
            <section
                className={stylesModules.FeaturesContainer}
            >
                {/*  Contenedor para mostar una lista de los filtros aplicados */}
                {enableFilters && (
                    <FiltersPopoverList
                        columnFilters={columnFilters}
                        setColumnFilters={setColumnFilters}
                        isVisible={isVisibleFiltersListPopover}
                        onToggle={handlerOnClickButtonFiltersList}
                        table={table}
                        triggerRef={triggerRefFilterList}
                        popoverRef={filterListPopoverRef}
                    />
                )}
                {/*  Contenedor para mostar una lista de los sorts aplicados */}
                {enableSorting && (
                    <SortsPopoverList
                        sorting={sorting}
                        setSorting={setSorting}
                        isVisible={isVisibleSortsListPopover}
                        onToggle={handlerOnClickButtonSortsList}
                        columns={columns}
                        triggerRef={triggerRefSortsList}
                        popoverRef={filterSortPopoverRef}
                    />
                )}
                {/*  Contenedor para esconder columnas */}
                {enableViews && (
                    <ColumnVisibilityPopover
                        isVisible={isVisibleHidePopover}
                        onToggle={handlerClickButtonVisibblePopoverHideColumn}
                        valueTextFieldColumnHide={valueTextFieldColumnHide}
                        onChangeTextFieldColumnHide={onChangeTextFieldColumnHide}
                        onClickButtonHideColumn={handlerOnClickButtonHideColumn}
                        columns={table.getAllColumns()}
                        triggerRef={triggerRef}
                        popoverRef={popoverRef}
                    />
                )}
                {/*  Contenedor para esconder columnas */}
                <div
                    className={stylesModules.extraButtonsContainer}
                >
                    {extraButtons?.map((action, index) => (
                        <button
                            style={{
                                display: "flex",
                                flexDirection: "row",
                                justifyContent: "center",
                                alignItems: "center",
                                gap: "0.5rem"
                            }}
                            key={index}
                            onClick={(e) => {
                                e.preventDefault();
                                action.onClick();
                            }}
                            disabled={action.disabled}
                            type="button"
                        >
                            {action.icon && <span>{action.icon}</span>}
                            <span>{action.label}</span>
                        </button>
                    ))}
                </div>
            </section>
            <section
                className={stylesModules.containerTable}
            >
                <table
                    className={stylesModules.table}
                >
                    {
                        table?.getRowModel()?.rows?.length >= 0 && (
                            <GeneratorHeaderTable
                                table={table}
                                enableSorting={enableSorting}
                                enableFilters={enableFilters}
                                isVisibleFilterPopover={isVisibleFilterPopover}
                                filterInputValues={filterInputValues}
                                filterTriggerRefs={filterTriggerRefs}
                                filterPopoverRef={filterPopoverRef}
                                handlerOnClickButtonFilter={handlerOnClickButtonFilter}
                                handlerOnClickButtonAddFilterColumn={handlerOnClickButtonAddFilterColumn}
                                handleOnClickButtonDeleteFilter={handleOnClickButtonDeleteFilter}
                                handlerOnChangeInputTextFilterColumn={handlerOnChangeInputTextFilterColumn}
                                handleOnClickButtonCommonValuesFilter={handleOnClickButtonCommonValuesFilter}
                                getValueFieldColumnFilter={getValueFieldColumnFilter}
                                toggleCycleSortingColumn={toggleCycleSortingColumn}
                                className={stylesModules.tableHeader}
                                typeRowActions={typeRowActions}
                            />
                        )}
                    {
                        table?.getRowModel()?.rows?.length >= 0 && (
                            <GeneratorBodyTable
                                table={table}
                                noResultsMessage={noResultsMessage}
                                className={stylesModules.tableBody}
                            />
                        )}
                </table>
                {
                    table?.getRowModel()?.rows?.length >= 0 &&
                    enablePagination && (
                        <TableFooterControls<T>
                            selectedRows={selectedRows}
                            deleteRowsSelected={deleteRowsSelected}
                            table={table}
                            onChangeSelectRowsPerPage={onChangeSelectRowsPerPage}
                            className={stylesModules.containerPagination}
                        />
                    )}
            </section>
        </div >
    );
};

export default GenericTable;
