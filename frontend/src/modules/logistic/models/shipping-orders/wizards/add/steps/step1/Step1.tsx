import type { ColumnDef, Row, RowSelectionState } from "@tanstack/react-table";
import GenericTable from "../../../../../../../../comp/primitives/table/tableContext/GenericTable";
import StyleModule from "./Step1.module.css";
import type { IPurchasedOrder } from "../../../../../../../../interfaces/purchasedOrder";
import CriticalActionButton from "../../../../../../../../comp/primitives/button/custom-button/critical-action/CriticalActionButton";
import MainActionButtonCustom from "../../../../../../../../comp/primitives/button/custom-button/main-action/MainActionButtonCustom";
import { ChevronRight, Search } from "lucide-react";
import { useCallback, useState } from "react";
import InputTextCustom from "../../../../../../../../comp/primitives/input/text/custom/InputTextCustom";
import usePurchasedOrders from "../../../../../../../../modelos/purchased_orders/hooks/usePurchasedOrders";
import { useShippingOrderDispatch, useShippingOrderState } from "../../../../context/shippingOrderHooks";
import { useMemo } from "react";
import type { IPartialPurchasedOrder } from "../../../../../../../../interfaces/purchasedOrder";
import { diffObjectArrays } from "./../../../../../../../../utils/validation-on-update/validationOnUpdate";
import { add_shipping_order_purchased_order_products_aux, next_step, remove_shipping_order_purchased_order_products_aux } from "../../../../context/shippingOrderActions";
import type { IPartialShippingOrderPurchasedOrderProduct } from "interfaces/shippingPurchasedProduct";
import type { IPurchasedOrderProduct } from "interfaces/purchasedOrdersProducts";
import { getEnumoSingleLabel, type TableStatePartial } from "../../../../../../../../comp/primitives/table/tableContext/tableTypes";
import Tag from "../../../../../../../../comp/primitives/tag/Tag";
import { generateRandomIds } from "../../../../../../../../helpers/nanoId";
import toastMantine from "../../../../../../../../comp/external/mantine/toast/base/ToastMantine";

interface IStep1 { onClose: () => void }

const Step1 = ({ onClose }: IStep1) => {

    const state = useShippingOrderState();
    const dispatch = useShippingOrderDispatch();

    const [purchase_orders, client, initialState]: [IPartialPurchasedOrder[], string, TableStatePartial] = useMemo(() => {

        const map = new Map<number | string, IPartialPurchasedOrder>();
        for (const item of state.data?.shipping_order_purchase_order_product_aux ?? []) {
            const po = item.purchase_order_products?.purchase_order as IPartialPurchasedOrder | undefined;
            if (po?.id != null) map.set(po.id, po);
        }
        const purchase_orders = [...map.values()];

        const client = [...purchase_orders].shift()?.client?.company_name || "";

        const rowSelectionState: RowSelectionState = {}
        purchase_orders.forEach(p => {
            rowSelectionState[p?.id?.toString() || ""] = true;
        });

        const initialState: TableStatePartial = {
            ...(Object.keys(rowSelectionState).length > 0 ? { rowSelectionState } : {})
        }

        return [purchase_orders, client, initialState];
    }, [state.data?.shipping_order_purchase_order_product_aux]);

    const [search, setSearch] = useState<string>(client);
    const [selectedPurchasedOrder, setSelectedPurchasedOrder] = useState<IPartialPurchasedOrder[]>(purchase_orders);
    const exclude = useMemo(() => ({ status: "shipping" as const }), []);
    const { purchasedOrders, loadingPurchasedOrders } = usePurchasedOrders({
        like: search,
        debounce: 500,
        conditionalExclude: exclude
    });


    const columns: ColumnDef<IPurchasedOrder>[] = useMemo(() => [
        {
            accessorKey: "order_code",
            header: "Order ID",
            meta: {
                hidden: false,
                autoGenerated: true,
                type: "string"
            }
        },
        {
            accessorKey: "created_at",
            header: "Fecha de orden",
            meta: {
                hidden: false,
                autoGenerated: true,
                type: "date",
                mode: "single"
            }
        },
        {
            id: "client",
            accessorFn: (row) => row.client?.company_name,
            header: "Cliente",
            meta: {
                hidden: false,
                autoGenerated: true,
                type: "string",
            }
        },
        {
            accessorKey: "delivery_date",
            header: "Fecha estimada de entrega",
            meta: {
                hidden: false,
                autoGenerated: true,
                type: "date",
                mode: "range"
            }
        },
        {
            id: "location",
            header: "Dirección de envío",
            accessorFn: (row) => row.shipping_address,
            meta: {
                hidden: false,
                autoGenerated: true,
                type: "string",
            },
        },
        {
            accessorKey: "status",
            header: "Estado",
            meta: {
                hidden: false,
                autoGenerated: true,
                type: "enum",
                enumOptions: [
                    { label: "Pendiente", value: "pending" },
                    { label: "Envío parcial", value: "partially_shipping" },
                    { label: "Enviado", value: "shipping" },
                    { label: "Finalizado", value: "finished" },
                ]
            },
            cell: ({ getValue, column }) => {
                const valor = getValue() as string;
                console.log(valor);
                const labelEnum = getEnumoSingleLabel(column.columnDef, valor) || "";
                return (
                    <Tag
                        label={labelEnum}
                        className={`${StyleModule[valor.toLowerCase()]}`}
                    />
                );
            }
        }
    ], []);

    const handleRowSelectionChange = useCallback((selected: IPurchasedOrder[]) => {
        const diffObject: {
            added: IPurchasedOrder[],
            deleted: IPurchasedOrder[]
        } = diffObjectArrays(selectedPurchasedOrder, selected);
        const { added, deleted } = diffObject;
        if (added.length > 0) {
            setSelectedPurchasedOrder(prev => [...prev, ...added]);
            const popsArray: IPurchasedOrderProduct[][] = added.map(p => p.purchase_order_products as IPurchasedOrderProduct[] ?? []);
            const popsFlat: IPurchasedOrderProduct[] = popsArray.flat().filter(p => Number(p.shipping_summary?.shipping_qty) < Number(p.shipping_summary?.order_qty));
            const sopops: IPartialShippingOrderPurchasedOrderProduct[] = popsFlat.map(p => ({
                id: generateRandomIds(),
                purchase_order_products: p,
                purchase_order_product_id: p.id,
                qty: (Number(p.shipping_summary?.order_qty) - Number(p.shipping_summary?.shipping_qty)) || 0,
            }));
            if (sopops.length > 0) {
                dispatch(add_shipping_order_purchased_order_products_aux(sopops));
            }
        }
        if (deleted.length > 0) {
            const poIds = deleted.map(p => p.id);
            setSelectedPurchasedOrder(prev => prev.filter(p => !poIds.includes(p.id || 0)));
            const pops = state.data?.shipping_order_purchase_order_product_aux?.filter(p => poIds.includes(p.purchase_order_products?.purchase_order_id || 0));
            const sopopsIds = (pops?.map(p => p.purchase_order_product_id) ?? []).filter((p): p is number => p !== undefined);
            if (sopopsIds.length > 0) {
                dispatch(remove_shipping_order_purchased_order_products_aux(sopopsIds));
            }
        }
    }, [state.data?.shipping_order_purchase_order_product_aux, dispatch]);

    const conditionalRowSelection = useCallback((updater: RowSelectionState, rows: Row<IPurchasedOrder>[],): boolean => {
        if (selectedPurchasedOrder.length === 0) {
            if (rows.length === Object.keys(updater).length) {
                const client = rows[0].original.client?.company_name;
                const shipping_address = rows[0].original.shipping_address;
                const records = rows.map(row => row.original);
                const isSameClient = records.every(
                    (p: IPurchasedOrder) => {
                        const sameClient = p.client?.company_name === client;
                        return sameClient;
                    }
                );
                const isSameAddress = records.every(
                    (p: IPurchasedOrder) => {
                        const sameAddress = p.shipping_address === shipping_address;
                        return sameAddress;
                    }
                );
                if (!isSameClient || !isSameAddress) {
                    toastMantine.feedBackForm({ message: 'Las ordenes seleccionadas deben pertenecer al mismo cliente y dirección de envío.' });
                }
                return isSameClient && isSameAddress;
            } else {
                return true;
            }
        } else {
            const keys: string[] = Object.keys(updater);
            const rowsRecords = rows.filter(row => keys.includes(row.id));
            const records = rowsRecords.map(row => row.original);
            const shipping_address = selectedPurchasedOrder[0].shipping_address;
            const isSameClient = records.every(
                (p: IPurchasedOrder) => {
                    const sameClient = p.client?.company_name === client;
                    return sameClient;
                }
            );
            const isSameAddress = records.every(
                (p: IPurchasedOrder) => {
                    const sameAddress = p.shipping_address === shipping_address;
                    return sameAddress;
                }
            );

            if (!isSameClient || !isSameAddress) {
                toastMantine.feedBackForm({ message: 'Las ordenes seleccionadas deben pertenecer al mismo cliente y dirección de envío.' });
            }
            return isSameClient && isSameAddress;
        }
    }, [client, purchase_orders]);

    const handleOnClickNext = useCallback(() => {
        if (selectedPurchasedOrder.length > 0) {
            dispatch(next_step());
        } else {
            toastMantine.feedBackForm({ message: 'Debes seleccionar al menos una orden.' });
        }
    }, [selectedPurchasedOrder, dispatch]);

    return (
        <div className={StyleModule.container}>
            <div className={StyleModule.headerSection}>
                <span className={`nunito - bold ${StyleModule.title} `}>Selecciona una orden</span>
                <InputTextCustom
                    value={search}
                    onChange={setSearch}
                    placeholder="Buscar"
                    icon={<Search />}
                    classNameInput={StyleModule.inputTextCustom}
                    withValidation={false}
                />
            </div>
            <GenericTable
                modelName="purchased_orders"

                /* distribuccion de columnas y rows */
                columns={columns}
                data={purchasedOrders ? purchasedOrders : []}
                isLoadingData={loadingPurchasedOrders}

                /* funcionalidades */
                enablePagination
                enableFilters
                enableSorting
                enableRowSelection
                /* acciones */
                getRowId={(row, _) => row.id.toString()}
                onRowSelectionChangeExternal={handleRowSelectionChange}
                conditionalRowSelection={conditionalRowSelection}
                initialState={initialState}
                classNameGenericTableContainer={StyleModule.genericTableContainer}
            />
            <div className={StyleModule.footerSection}>
                <CriticalActionButton
                    onClick={onClose}
                    label="Cancelar"
                />
                <MainActionButtonCustom
                    onClick={handleOnClickNext}
                    label="Siguiente"
                    icon={<ChevronRight />}
                />
            </div>

        </div>
    )
}

export default Step1;
